//+------------------------------------------------------------------+
//|                                                      DIAMOND.mq5 |
//|                  Version 40 - Optimisée, Documentée et Complète |
//|                                  Copyright 2024, Amir Bensmail   |
//|                                       https://github.com/amirbs14 |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, Amir BS"
#property link      "https://github.com/"
#property version   "40.0"
#property strict

//===================================================
// SECTION 1 : INCLUDES ET CONFIGURATION DE BASE
//===================================================
#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\HistoryOrderInfo.mqh>
#include <Trade\DealInfo.mqh>
#include <Indicators\Trend.mqh>
#include <Indicators\Oscilators.mqh>
#include <Indicators\Volumes.mqh>
#include <Generic\ArrayList.mqh>
#include <Arrays\ArrayObj.mqh>
#include <Generic\HashMap.mqh>
#include <ChartObjects\ChartObjectsTxtControls.mqh>
#include <ChartObjects\ChartObjectsShapes.mqh>
#include <Generic\HashSet.mqh>

//===================================================
// SECTION 2 : CONSTANTES GLOBALES ET DEFINITIONS
//===================================================
#define STRATEGY_COUNT 8                // Nombre total de stratégies
#define MAX_POSITIONS_PER_SYMBOL 3      // Positions max par symbole
#define MAX_SYMBOLS 20                  // Symboles max suivis
#define MAX_RETRIES 5                   // Tentatives de lecture indicateurs
#define MIN_BARS_REQUIRED 100           // Barres minimum requises
#define PARTIAL_CLOSE_PERCENT 30.0      // Pourcentage de fermeture partielle
#define PERFORMANCE_SAVE_INTERVAL 3600  // Intervalle de sauvegarde (sec)
#define TRADING_HOURS_START 1           // Heure de début de trading (UTC)
#define TRADING_HOURS_END 23            // Heure de fin de trading (UTC)

// Couleurs du dashboard
#define PANEL_COLOR clrBlack            // Fond noir (plus lisible)
#define TEXT_COLOR clrWhite
#define POSITIVE_COLOR clrLime
#define NEGATIVE_COLOR clrRed
#define WARNING_COLOR clrOrange
#define INFO_COLOR clrDodgerBlue

// Constantes Ichimoku
#define MODE_TENKANSEN    0
#define MODE_KIJUNSEN     1
#define MODE_SENKOUSPANA  2
#define MODE_SENKOUSPANB  3

//===================================================
// SECTION 2bis : NOUVELLES DEFINITIONS
//===================================================
enum ENUM_MARKET_CONDITION {
   MARKET_CALM,        // Marché calme
   MARKET_MODERATE,    // Marché modéré
   MARKET_VOLATILE     // Marché volatile
};

//===================================================
// SECTION 3 : STRUCTURES DE DONNEES
//===================================================
enum ENUM_STRATEGY {
   STRAT_NONE = 0,          // Aucune stratégie
   S_CHECKLIST = 1,     // Stratégie checklist
   S_BREAKOUT_RANGE = 2,// Stratégie breakout
   S_PULLBACK_EMA = 3,  // Stratégie pullback EMA
   S_SUPERTREND = 4,    // Stratégie SuperTrend
   S_RETEST_SR = 5,     // Stratégie retest support/résistance
   S_SCALPING = 6,      // Stratégie scalping
   S_ICHIMOKU = 7,      // Stratégie Ichimoku
   S_PRICE_ACTION = 8   // Stratégie Price Action
};

struct SStrategyPerformance {
   ENUM_STRATEGY strategy;     // Type de stratégie
   int totalTrades;            // Nombre total de trades
   int wins;                   // Trades gagnants
   int losses;                 // Trades perdants
   double totalProfit;         // Profit total
   double winRate;             // Taux de réussite
   double profitFactor;        // Facteur de profit
   bool enabled;               // Statut d'activation
   datetime lastTradeTime;     // Heure du dernier trade
   double weight;              // Poids dans la sélection
   double recentPerformance;   // Performance récente (30 derniers jours)
};

struct STradeSignal {
   bool valid;                 // Validité du signal
   bool isBuySignal;           // Signal d'achat si vrai
   double price;               // Prix d'entrée
   double sl;                  // Niveau de stop-loss
   double tp;                  // Niveau de take-profit
   ENUM_STRATEGY strategy;     // Stratégie générant le signal
   string comment;             // Commentaire descriptif
   int confirmations;          // Nombre de confirmations
   double strength;            // Force du signal (0-100)
};

struct SSymbolStats {
   string symbol;              // Symbole du marché
   int totalTrades;            // Trades totaux
   int winTrades;              // Trades gagnants
   int lossTrades;             // Trades perdants
   int todayTrades;            // Trades aujourd'hui
   int todayWins;              // Gains aujourd'hui
   int todayLosses;            // Pertes aujourd'hui
   double spreadSum;           // Somme des spreads
   int spreadCount;            // Nombre de spreads enregistrés
   double spreadMax;           // Spread maximum observé
   double lastSpread;          // Dernier spread enregistré
};

//===================================================
// SECTION 4 : PARAMETRES D'ENTREE
//===================================================
input group "==== Paramètres Généraux ===="
input int MinStrategyConfirmations = 3;  // Nombre minimal de stratégies pour autoriser un trade
input int MagicNumber = 20200520;        // Magic number unique
input bool EnableNotifications = true;   // Activer les notifications
input bool EnableSoundAlerts = true;     // Activer les alertes sonores
input bool EnableDebugLog = true;        // Activer les logs détaillés
input bool EnableAutoLotSize = true;     // Calcul automatique de la taille de position
input bool EnableBacktestMode = false;   // Mode backtest (désactive le trading réel)
input bool EnableTradingHours = true;    // Activer les heures de trading
input int TradingStartHour = 1;          // Heure de début de trading (UTC)
input int TradingEndHour = 23;           // Heure de fin de trading (UTC)

input group "==== Gestion des Risques ===="
input double MaxDailyLossPercent = 5.0;  // Perte quotidienne max (% du balance)
input double MaxLossPercent = 2.0;       // Perte max par trade (% du balance)
input int MaxConsecutiveLosses = 10;     // Pertes consécutives max avant pause
input int PauseAfterLosses = 5;          // Pause après X pertes consécutives
input int PauseDurationMinutes = 30;     // Durée de pause en minutes
input int MinMinutesBetweenTrades = 5;   // Temps minimum entre trades
input double PartialClosePercent = 30.0; // % à fermer quand TP1 atteint
input double PartialCloseATRMultiplier = 2.0; // Multiplicateur ATR pour sortie partielle
input bool EnableMartingale = false;     // Activer le système de martingale
input double MartingaleMultiplier = 2.0; // Multiplicateur pour martingale
input int MaxMartingaleSteps = 3;        // Nombre max de steps martingale

input group "==== Paramètres de Trading ===="
input double RiskPercent = 1.0;          // Pourcentage de risque
input double InitialLot = 0.01;          // Taille de lot initiale
input double MaxLot = 0.5;              // Taille de lot maximum (corrigé à 0.05)
input int Slippage = 1;                  // Slippage max (points)
input bool EnableBreakeven = true;       // Activer le breakeven stop
input double BreakevenATRMultiplier = 1.0; // Multiplicateur ATR pour breakeven
input double BreakevenTriggerATR = 1.5;  // Multiplicateur ATR pour déclencher breakeven

input group "==== Paramètres de Spread Dynamique ===="
input double EURUSD_MaxSpread = 2.0;     // Spread max pour EURUSD (pips)
input double USDJPY_MaxSpread = 2.5;     // Spread max pour USDJPY (pips)
input double GBPUSD_MaxSpread = 2.2;     // Spread max pour GBPUSD (pips)
input double XAUUSD_MaxSpread = 30.0;    // Spread max pour XAUUSD/GOLD (pips)
input double BTCUSD_MaxSpread = 2500.0;  // Spread max pour BTCUSD (pips)
input double SpreadMultiplier = 1.5;     // Multiplicateur de sécurité pour le spread

input group "==== Paramètres des Stratégies ===="
input bool EnableStrategyAutoManagement = true; // Gestion automatique des stratégies
input int MinTradesToDisable = 20;       // Trades min avant désactivation
input double MinWinRateToDisable = 40.0; // Taux de réussite min (%)
input int ReEnableAfterHours = 24;       // Heures avant réactivation
input bool UseTrendFilter = true;        // Utiliser le filtre de tendance EMA100/Ichimoku
input double StrategyWeight_Checklist = 1.0; // Poids stratégie Checklist
input double StrategyWeight_Breakout = 1.0;  // Poids stratégie Breakout
input double StrategyWeight_Pullback = 1.0;  // Poids stratégie Pullback
input double StrategyWeight_SuperTrend = 1.0; // Poids stratégie SuperTrend
input double StrategyWeight_SRRetest = 1.0;  // Poids stratégie SR Retest
input double StrategyWeight_Scalping = 1.0;  // Poids stratégie Scalping
input double StrategyWeight_Ichimoku = 1.0;  // Poids stratégie Ichimoku
input double StrategyWeight_PriceAction = 1.0; // Poids stratégie Price Action

input group "==== Paramètres SuperTrend ===="
input int SuperTrend_ATRPeriod = 10;     // Période ATR pour SuperTrend
input double SuperTrend_Multiplier = 3.0;// Multiplicateur pour SuperTrend
input bool EnableSuperTrendInput = true; // Activer la stratégie SuperTrend

input group "==== Paramètres Checklist ===="
input int Checklist_MACD_Fast = 8;       // Période rapide MACD
input int Checklist_MACD_Slow = 20;      // Période lente MACD
input int Checklist_MACD_Signal = 9;     // Période signal MACD
input double Checklist_RSI_Min = 30.0;   // Niveau minimum RSI
input double Checklist_RSI_Max = 70.0;   // Niveau maximum RSI
input double Checklist_ADX_Min = 10.0;   // Niveau minimum ADX

input group "==== Paramètres Dashboard ===="
input int DashboardPosX = 20;            // Position X du dashboard (pixels)
input int DashboardPosY = 40;            // Position Y du dashboard (pixels)
input int DashboardWidth = 420;          // Largeur du dashboard (pixels)
input int DashboardHeight = 500;         // Hauteur augmentée pour le nouveau dashboard
input double MaxProgressBarValue = 100.0; // Valeur maximale pour la progress bar

input group "==== Multiplicateurs ATR pour SL / TP ===="
input double InpSLatrMult = 1.5;   // SL = 1.5 × ATR
input double InpTPatrMult = 3.0;   // TP = 3.0 × ATR

input group "==== Paramètres Notifications ===="
input string TelegramToken = "";    // Token du bot Telegram
input string TelegramChatId = "";   // ID du chat Telegram
input string EmailAddress = "";     // Adresse email pour notifications

input group "==== Paramètres ATR ===="
input int ATRPeriod = 14;              // Période pour l'indicateur ATR

//===================================================
// SECTION 5 : VARIABLES GLOBALES
//===================================================
double g_SLatrMult;
double g_TPatrMult;
double g_SuperTrendMultiplier;

// Gestion du temps
datetime lastOptimization = 0;
datetime lastPerformanceSaveTime = 0;
datetime lastTradeTime = 0;                 // Heure du dernier trade

// Suivi des performances
double g_LastEquity = 0.0;                  // Dernière valeur d'equity
double g_LastBalance = 0.0;                 // Dernière valeur de balance
double g_ATRValue = 0.0;                    // Valeur ATR courante
SStrategyPerformance strategyPerformance[STRATEGY_COUNT];
SSymbolStats stats[MAX_SYMBOLS];
int symbolCount = 0;
int g_ConsecutiveLosses = 0;                // Pertes consécutives
double g_LastLotSize = 0.0;                 // Dernière taille de lot utilisée
int g_MartingaleStep = 0;                   // Étape actuelle de martingale

// Handles et objets globaux
CTrade trade;
CPositionInfo positionInfo;
CHistoryOrderInfo historyOrder;
CDealInfo dealInfo;
int macdHandle, rsiHandle, atrHandle, adxHandle, bbHandle, emaHandle, ema200Handle, superTrendHandle, checklistMacdHandle;
int trendFilterHandle; // Handle pour le filtre de tendance (EMA100 ou Ichimoku)
int ichimokuHandle;    // Handle pour Ichimoku

// Flags d'état
bool ea_is_active = true;
bool g_IsGold = false;
bool g_IsCrypto = false;
string g_SymbolGold1 = "GOLD";
string g_SymbolGold2 = "XAUUSD";
string g_SymbolBTC = "BTCUSD";

// Cache pour les indicateurs
double g_CachedATR = 0.0;
datetime g_LastATRUpdate = 0;
  

//===================================================
// SECTION 6 : CLASSES PRINCIPALES
//===================================================

//+------------------------------------------------------------------+
//| Classe CRiskManager - Gestion avancée des risques               |
//+------------------------------------------------------------------+
class CRiskManager {
private:
   double maxDailyLossPercent;
   double maxLossPercent;
   int maxConsecutiveLosses;
   int pauseAfterLosses;
   int pauseDurationMinutes;
   int consecutiveLosses;
   datetime pauseUntil;
   datetime lastTradeTime;

public:
   CRiskManager(double dailyLossPct, double lossPct, int maxConsLoss, int pauseLoss, int pauseMin) :
      maxDailyLossPercent(dailyLossPct),
      maxLossPercent(lossPct),
      maxConsecutiveLosses(maxConsLoss),
      pauseAfterLosses(pauseLoss),
      pauseDurationMinutes(pauseMin),
      consecutiveLosses(0),
      pauseUntil(0),
      lastTradeTime(0) {}
   
   bool IsTradeAllowed() const {
      if (pauseUntil > TimeCurrent()) {
         Print("⛔ Pause de trading active jusqu'à ", TimeToString(pauseUntil, TIME_MINUTES));
         return false;
      }

      double balance = AccountInfoDouble(ACCOUNT_BALANCE);
      double equity = AccountInfoDouble(ACCOUNT_EQUITY);
      if (balance <= 0) return false;

      double dailyLoss = ((balance - equity) / balance) * 100.0;

      if (dailyLoss >= maxDailyLossPercent) {
         PrintFormat("❌ Limite de perte quotidienne dépassée: %.2f%% ≥ %.2f%%", dailyLoss, maxDailyLossPercent);
         return false;
      }

      if (consecutiveLosses >= maxConsecutiveLosses) {
         PrintFormat("❌ Limite de pertes consécutives atteinte: %d", consecutiveLosses);
         return false;
      }

      return true;
   }

   void UpdateTradeResult(double profit) {
      if (profit < 0) {
         consecutiveLosses++;
         if (consecutiveLosses >= pauseAfterLosses) {
            pauseUntil = TimeCurrent() + pauseDurationMinutes * 60;
            PrintFormat("🚫 Pause de trading pour %d minutes après %d pertes", pauseDurationMinutes, consecutiveLosses);
         }
      } else {
         consecutiveLosses = 0;
      }
      lastTradeTime = TimeCurrent();
   }

   double CalculatePositionSize(double entry, double stopLoss) const {
      if (!EnableAutoLotSize) return InitialLot;
      
      if (entry <= 0 || stopLoss <= 0) {
         Print("❗ Prix ou SL invalide pour le calcul des lots");
         return 0.0;
      }

      double stopDistance = MathAbs(entry - stopLoss);
      if (stopDistance < _Point) {
         Print("❗ SL trop proche du prix d'entrée");
         return 0.0;
      }

      // Appliquer le multiplicateur martingale si nécessaire
      double riskMultiplier = 1.0;
      if(EnableMartingale && g_ConsecutiveLosses > 0 && g_MartingaleStep < MaxMartingaleSteps) {
         riskMultiplier = MathPow(MartingaleMultiplier, g_MartingaleStep);
         PrintFormat("Martingale active - Step %d, Multiplicateur: %.2f", 
                    g_MartingaleStep, riskMultiplier);
      }

      double riskAmount = AccountInfoDouble(ACCOUNT_BALANCE) * (MaxLossPercent / 100.0) * (RiskPercent / 100.0) * riskMultiplier;

      double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
      double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
      double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
      double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
      double maxLot = MaxLot; // Utilisation de la valeur input MaxLot

      if (tickValue == 0 || tickSize == 0 || lotStep == 0) {
         Print("❗ Information marché indisponible (taille/valeur du tick)");
         return 0.0;
      }

      double costPerLot = stopDistance / tickSize * tickValue;
      if (costPerLot <= 0) {
         Print("❗ Distance de stop ou valeurs de tick invalides");
         return 0.0;
      }

      double rawLots = riskAmount / costPerLot;
      double roundedLots = MathFloor(rawLots / lotStep) * lotStep;

      // Application des limites
      roundedLots = MathMax(minLot, MathMin(roundedLots, maxLot));

      if (roundedLots < minLot) {
         PrintFormat("❗ Taille de lot calculée %.2f en dessous du minimum %.2f", roundedLots, minLot);
         return 0.0;
      }

      return roundedLots;
   }

   int GetOpenPositionsCount(const string symbol) const {
      int count = 0;
      for (int i = 0; i < PositionsTotal(); i++) {
         ulong ticket = PositionGetTicket(i);
         if (PositionSelectByTicket(ticket)) {
            string sym = PositionGetString(POSITION_SYMBOL);
            int magic = (int)PositionGetInteger(POSITION_MAGIC);
            if (sym == symbol && magic == MagicNumber) {
               count++;
            }
         }
      }
      return count;
   }

   bool CheckMinTimeBetweenTrades(int minMinutes) const {
      if (lastTradeTime == 0) return true;
      return (TimeCurrent() - lastTradeTime) >= (minMinutes * 60);
   }

   void ResetConsecutiveLosses() {
      consecutiveLosses = 0;
      pauseUntil = 0;
      Print("✅ Pertes consécutives réinitialisées");
   }
};

//+------------------------------------------------------------------+
//| Classe CNotificationManager - Gestion des notifications          |
//+------------------------------------------------------------------+
class CNotificationManager {
private:
   string m_telegramToken;
   string m_telegramChatId;
   string m_emailAddress;
   
public:
   CNotificationManager(string token, string chatId, string email) :
      m_telegramToken(token),
      m_telegramChatId(chatId),
      m_emailAddress(email) {}
   
   void SendNotification(string message) {
      // Notification standard (alerte MT5)
      if(EnableNotifications) Alert(message);
      
      // Notification sonore
      if(EnableSoundAlerts) PlaySound("alert.wav");
      
      // Notification Telegram si configuré
      if(m_telegramToken != "" && m_telegramChatId != "") {
         SendTelegramMessage(message);
      }
      
      // Notification email si configuré
      if(m_emailAddress != "") {
         SendEmailNotification(message);
      }
   }
   
private:
   void SendTelegramMessage(string message) {
      string url = "https://api.telegram.org/bot" + m_telegramToken + "/sendMessage";
      string params = "chat_id=" + m_telegramChatId + "&text=" + message;
      
      // Utilisation de WebRequest pour envoyer le message
      char data[], result[];
      string headers;
      int timeout = 5000; // 5 secondes
      
      StringToCharArray(params, data, 0, StringLen(params));
      
      int res = WebRequest("POST", url, headers, timeout, data, result, headers);
      
      if(res == -1) {
         Print("Erreur lors de l'envoi du message Telegram: ", GetLastError());
      }
   }
   
   void SendEmailNotification(string message) {
      string subject = "Notification EA DIAMOND - " + _Symbol;
      SendMail(subject, message);
   }
};

//+------------------------------------------------------------------+
//| Classe CStrategyManager - Gestion complète des stratégies        |
//| Version 40 - Optimisée pour stabilité et performance           |
//+------------------------------------------------------------------+
class CStrategyManager {
private:
   // Handles des indicateurs
   int macdHandle;          // Handle de l'indicateur MACD
   int rsiHandle;           // Handle de l'indicateur RSI
   int atrHandle;           // Handle de l'indicateur ATR
   int adxHandle;           // Handle de l'indicateur ADX
   int bbHandle;            // Handle des Bandes de Bollinger
   int emaHandle;           // Handle de la EMA 20
   int ema200Handle;        // Handle de la EMA 200
   int superTrendHandle;    // Handle de l'indicateur SuperTrend
   int checklistMacdHandle; // Handle MACD pour la stratégie Checklist
   int trendFilterHandle;   // Handle du filtre de tendance (EMA100/Ichimoku)
   int ichimokuHandle;      // Handle pour Ichimoku

   bool InitIndicatorWithRetry(int &handle, int newHandle, const string name, int retries = MAX_RETRIES) {
      handle = newHandle;
      int attempts = 0;
      
      while(handle == INVALID_HANDLE && attempts < retries) {
         PrintFormat("Tentative %d/%d pour %s", attempts+1, retries, name);
         Sleep(300); // Délai entre les tentatives
         handle = newHandle;
         attempts++;
      }
      
      if(handle == INVALID_HANDLE) {
         Print("Échec critique : Impossible d'initialiser ", name);
         return false;
      }
      return true;
   }

   void AutoManageStrategies() {
      if(!EnableStrategyAutoManagement) return;
      
      for(int i = 0; i < STRATEGY_COUNT; i++) {
         // Désactivation des stratégies sous-performantes
         if(strategyPerformance[i].totalTrades >= MinTradesToDisable && 
            strategyPerformance[i].winRate < MinWinRateToDisable) {
            strategyPerformance[i].enabled = false;
            PrintFormat("Stratégie %s désactivée (WinRate: %.1f%%)", 
                       EnumToString(strategyPerformance[i].strategy), 
                       strategyPerformance[i].winRate);
         }
         
         // Réactivation après le délai configuré
         if(!strategyPerformance[i].enabled && 
            TimeCurrent() - strategyPerformance[i].lastTradeTime > ReEnableAfterHours * 3600) {
            strategyPerformance[i].enabled = true;
            strategyPerformance[i].totalTrades = 0;
            strategyPerformance[i].wins = 0;
            strategyPerformance[i].losses = 0;
            PrintFormat("Stratégie %s réactivée", EnumToString(strategyPerformance[i].strategy));
         }
      }
   }
   
   // ------- Nouvelle Fonction pour les données des performances des Stratégies --------//
    void UpdateStrategyPerformance(ENUM_STRATEGY strategy, double profit) {
      int index = (int)strategy - 1;
      if(index >= 0 && index < STRATEGY_COUNT) {
         strategyPerformance[index].totalTrades++;
         if(profit >= 0) {
            strategyPerformance[index].wins++;
            strategyPerformance[index].totalProfit += profit;
         } else {
            strategyPerformance[index].losses++;
            strategyPerformance[index].totalProfit += profit;
         }
         
         // Calcul du win rate
         if(strategyPerformance[index].totalTrades > 0) {
            strategyPerformance[index].winRate = 
               (double)strategyPerformance[index].wins / 
               strategyPerformance[index].totalTrades * 100.0;
         }
         
         strategyPerformance[index].lastTradeTime = TimeCurrent();
      }
   }
   
   
public:
   CStrategyManager() :
      macdHandle(INVALID_HANDLE),
      rsiHandle(INVALID_HANDLE),
      atrHandle(INVALID_HANDLE),
      adxHandle(INVALID_HANDLE),
      bbHandle(INVALID_HANDLE),
      emaHandle(INVALID_HANDLE),
      ema200Handle(INVALID_HANDLE),
      superTrendHandle(INVALID_HANDLE),
      checklistMacdHandle(INVALID_HANDLE),
      trendFilterHandle(INVALID_HANDLE),
      ichimokuHandle(INVALID_HANDLE) {
      if(_Symbol != NULL && _Period != 0)
         InitializeIndicators();
   }

   ~CStrategyManager() {
      ReleaseAllHandles();
   }

   bool InitializeIndicators() {
      ReleaseAllHandles(); // Nettoyage préalable
      bool allSuccessful = true;

      // Configuration MACD (pour Checklist)
      allSuccessful &= InitIndicatorWithRetry(macdHandle,
         iMACD(_Symbol, _Period, Checklist_MACD_Fast, Checklist_MACD_Slow,
               Checklist_MACD_Signal, PRICE_CLOSE), "MACD Checklist");

      // Configuration RSI
      allSuccessful &= InitIndicatorWithRetry(rsiHandle,
         iRSI(_Symbol, _Period, 14, PRICE_CLOSE), "RSI 14");

      // Configuration ATR
      allSuccessful &= InitIndicatorWithRetry(atrHandle,
         iATR(_Symbol, _Period, ATRPeriod), "ATR 14");

      // Configuration ADX
      allSuccessful &= InitIndicatorWithRetry(adxHandle,
         iADX(_Symbol, _Period, 14), "ADX 14");

      // Configuration Bollinger Bands
      allSuccessful &= InitIndicatorWithRetry(bbHandle,
         iBands(_Symbol, _Period, 20, 2.0, 0, PRICE_CLOSE), "Bollinger Bands");

      // Configuration EMA 20
      allSuccessful &= InitIndicatorWithRetry(emaHandle,
         iMA(_Symbol, _Period, 20, 0, MODE_EMA, PRICE_CLOSE), "EMA 20");

      // Configuration EMA 200 (filtre de tendance)
      allSuccessful &= InitIndicatorWithRetry(ema200Handle,
         iMA(_Symbol, _Period, 200, 0, MODE_EMA, PRICE_CLOSE), "EMA 200");

      // Configuration SuperTrend (si activé dans les paramètres)
      if(EnableSuperTrendInput) {
         superTrendHandle = iCustom(_Symbol, _Period, "SuperTrend",
                                  SuperTrend_ATRPeriod, SuperTrend_Multiplier);
         allSuccessful &= InitIndicatorWithRetry(superTrendHandle, superTrendHandle, "SuperTrend");
      }

      // Configuration Ichimoku
      ichimokuHandle = iIchimoku(_Symbol, _Period, 9, 26, 52);
      allSuccessful &= InitIndicatorWithRetry(ichimokuHandle, ichimokuHandle, "Ichimoku");

      checklistMacdHandle = macdHandle; // Réutilisation du handle MACD

      return allSuccessful;
   }
    
    //+------------------------------------------------------------------+
   //| Détection de la tendance basée sur le timeframe                  |
   //+------------------------------------------------------------------+
   bool IsTrendBullish(ENUM_TIMEFRAMES tf) {
      int barsToAnalyze = 30; // Valeur par défaut pour M1
      
      // Détermination du nombre de bougies à analyser selon le timeframe
      switch(tf) {
         case PERIOD_M1:  barsToAnalyze = 30; break;
         case PERIOD_M5:  barsToAnalyze = 15; break;
         case PERIOD_M15: barsToAnalyze = 10; break;
         case PERIOD_M30: barsToAnalyze = 8;  break;
         case PERIOD_H1:  barsToAnalyze = 6;  break;
         case PERIOD_H4:  barsToAnalyze = 4;  break;
         default:         barsToAnalyze = 30; break;
      }
      
      // Calcul de la tendance basée sur les closes
      double sum = 0;
      for(int i = 1; i <= barsToAnalyze; i++) {
         double close1 = iClose(_Symbol, tf, i);
         double close2 = iClose(_Symbol, tf, i+1);
         sum += close1 - close2;
      }
      
      return sum > 0; // Tendance haussière si la somme est positive
   }

   void ReleaseAllHandles() {
      int handles[] = {macdHandle, rsiHandle, atrHandle, adxHandle,
                      bbHandle, emaHandle, ema200Handle,
                      superTrendHandle, checklistMacdHandle,
                      trendFilterHandle, ichimokuHandle};
      
      for(int i = 0; i < ArraySize(handles); i++) {
         if(handles[i] != INVALID_HANDLE) {
            IndicatorRelease(handles[i]);
            handles[i] = INVALID_HANDLE;
         }
      }
   }

   bool AreIndicatorsReady() {
      int requiredIndicators[9];
      int count = 0;

      requiredIndicators[count++] = macdHandle;
      requiredIndicators[count++] = rsiHandle;
      requiredIndicators[count++] = atrHandle;
      requiredIndicators[count++] = adxHandle;
      requiredIndicators[count++] = bbHandle;
      requiredIndicators[count++] = emaHandle;
      requiredIndicators[count++] = ema200Handle;
      requiredIndicators[count++] = ichimokuHandle;

      if(EnableSuperTrendInput && superTrendHandle != INVALID_HANDLE)
         requiredIndicators[count++] = superTrendHandle;

      double buffer[];
      for(int i = 0; i < count; i++) {
         if(requiredIndicators[i] == INVALID_HANDLE || 
            CopyBuffer(requiredIndicators[i], 0, 0, 1, buffer) <= 0 || 
            !MathIsValidNumber(buffer[0])) {
            Print("Indicateur non prêt : ", GetIndicatorName(requiredIndicators[i]));
            return false;
         }
      }
      return true;
   }

   double GetSpreadPips() {
      long spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
      double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
      double pipSize = (_Digits == 3 || _Digits == 5) ? 10 * point : point;
      return spread * point / pipSize;
   }

   double GetMaxSpreadForSymbol() {
      string symbol = _Symbol;
      
      if(symbol == "EURUSDm") return EURUSD_MaxSpread * SpreadMultiplier;
      if(symbol == "USDJPYm") return USDJPY_MaxSpread * SpreadMultiplier;
      if(symbol == "GBPUSDm") return GBPUSD_MaxSpread * SpreadMultiplier;
      if(symbol == "XAUUSDm" || symbol == "GOLD") return XAUUSD_MaxSpread * SpreadMultiplier;
      if(symbol == "BTCUSDm") return BTCUSD_MaxSpread * SpreadMultiplier;
      
      return 50.0 * SpreadMultiplier;
   }

   bool CheckSpread() {
      double currentSpread = GetSpreadPips();
      double maxAllowedSpread = GetMaxSpreadForSymbol();
      
      if(currentSpread > maxAllowedSpread) {
         PrintFormat("Spread trop élevé : %.1f pips > limite de %.1f pips", 
                    currentSpread, maxAllowedSpread);
         return false;
      }
      return true;
   }

  /**
 * Fonction SetStopLossTakeProfit - Calcule les niveaux de SL et TP
 * @param signal Structure contenant les informations du signal
 * @param isBuySignal Booléen indiquant si c'est un signal d'achat
 * 
 * Cette fonction calcule les niveaux de stop loss et take profit
 * en se basant sur la volatilité actuelle du marché (ATR) et les
 * multiplicateurs configurés qui s'adaptent aux conditions du marché.
 */
void SetStopLossTakeProfit(STradeSignal &signal, const bool isBuySignal) {
   double atr_val = GetCurrentATR();
   
   if(atr_val <= 0.0)
      atr_val = _Point * 50;

   // Les multiplicateurs sont ajustés selon AnalyzeMarketCondition()
   const double sl_mult = g_SLatrMult;
   const double tp_mult = g_TPatrMult;

   if(isBuySignal) {
      signal.sl = signal.price - (atr_val * sl_mult);
      signal.tp = signal.price + (atr_val * tp_mult);
   }
   else {
      signal.sl = signal.price + (atr_val * sl_mult);
      signal.tp = signal.price - (atr_val * tp_mult);
   }

   // Vérification des niveaux de stop minimum
   double stop_level = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL) * _Point;
   double safety_buf = _Point * 5;

   if(isBuySignal) {
      if(signal.price - signal.sl < stop_level + safety_buf)
         signal.sl = signal.price - (stop_level + safety_buf);

      if(signal.tp - signal.price < stop_level + safety_buf)
         signal.tp = signal.price + (stop_level + safety_buf);
   }
   else {
      if(signal.sl - signal.price < stop_level + safety_buf)
         signal.sl = signal.price + (stop_level + safety_buf);

      if(signal.price - signal.tp < stop_level + safety_buf)
         signal.tp = signal.price - (stop_level + safety_buf);
   }

   signal.sl = NormalizeDouble(signal.sl, _Digits);
   signal.tp = NormalizeDouble(signal.tp, _Digits);
}
//-----------------------------------------------------//

   double GetCurrentATR() {
      // Utilisation du cache pour éviter des appels répétés
      if(TimeCurrent() - g_LastATRUpdate <= 60 && g_CachedATR > 0) {
         return g_CachedATR;
      }
      
      double atr_val = 0.0;
      if(atrHandle != INVALID_HANDLE) {
         double buf[];
         if(CopyBuffer(atrHandle, 0, 0, 1, buf) > 0 && MathIsValidNumber(buf[0])) {
            atr_val = buf[0];
            g_CachedATR = atr_val;
            g_LastATRUpdate = TimeCurrent();
         }
      }
      return atr_val;
   }

   bool ChecklistStrategySignal(STradeSignal &signal) {
      signal.valid = false;
      
      double macdMain[], macdSignal[];
      int copiedMain   = CopyBuffer(checklistMacdHandle, 0, 0, 3, macdMain);
      int copiedSignal = CopyBuffer(checklistMacdHandle, 1, 0, 3, macdSignal);
      if(copiedMain < 2 || copiedSignal < 2)
         return false;

      double rsi[];
      if(CopyBuffer(rsiHandle, 0, 0, 1, rsi) <= 0)
         return false;

      double adx[];
      if(CopyBuffer(adxHandle, 0, 0, 1, adx) <= 0)
         return false;

      bool buyConditions = (macdMain[0] > macdSignal[0] && macdMain[1] <= macdSignal[1]) &&
                          (rsi[0] > Checklist_RSI_Min && rsi[0] < Checklist_RSI_Max) &&
                          (adx[0] > Checklist_ADX_Min);

      bool sellConditions = (macdMain[0] < macdSignal[0] && macdMain[1] >= macdSignal[1]) &&
                           (rsi[0] < Checklist_RSI_Max && rsi[0] > Checklist_RSI_Min) &&
                           (adx[0] > Checklist_ADX_Min);

      if(buyConditions) {
         signal.isBuySignal = true;
         signal.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         signal.strategy = S_CHECKLIST;
         signal.comment = "Checklist-BUY (MACD+RSI+ADX)";
         signal.strength = 80.0; // Force du signal (sur 100)
      }
      else if(sellConditions) {
         signal.isBuySignal = false;
         signal.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         signal.strategy = S_CHECKLIST;
         signal.comment = "Checklist-SELL (MACD+RSI+ADX)";
         signal.strength = 80.0; // Force du signal (sur 100)
      }
      else {
         return false;
      }

      SetStopLossTakeProfit(signal, signal.isBuySignal);
      signal.confirmations = 3;
      signal.valid = true;
      
      return true;
   }

   bool DetectSuperTrendSignal(STradeSignal &signal) {
      signal.valid = false;
      
      if(superTrendHandle == INVALID_HANDLE || !EnableSuperTrendInput)
         return false;

      double superTrend[];
      if(CopyBuffer(superTrendHandle, 0, 0, 1, superTrend) <= 0)
         return false;

      double currentPrice = iClose(_Symbol, _Period, 0);
      
      if(currentPrice > superTrend[0]) {
         signal.isBuySignal = true;
         signal.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         signal.strength = 70.0;
      }
      else if(currentPrice < superTrend[0]) {
         signal.isBuySignal = false;
         signal.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         signal.strength = 70.0;
      }
      else {
         return false;
      }

      SetStopLossTakeProfit(signal, signal.isBuySignal);
      signal.strategy = S_SUPERTREND;
      signal.comment = "SuperTrend Signal";
      signal.confirmations = 1;
      signal.valid = true;
      
      return true;
   }

   bool DetectSRRetestSignal(STradeSignal &signal) {
      signal.valid = false;
      
      double bbUpper[], bbLower[];
      if(CopyBuffer(bbHandle, 1, 0, 1, bbUpper) <= 0 ||
         CopyBuffer(bbHandle, 2, 0, 1, bbLower) <= 0)
         return false;

      double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      
      if(bid <= bbLower[0] + _Point * 2) {
         signal.isBuySignal = true;
         signal.price = ask;
         signal.strength = 75.0;
      }
      else if(ask >= bbUpper[0] - _Point * 2) {
         signal.isBuySignal = false;
         signal.price = bid;
         signal.strength = 75.0;
      }
      else {
         return false;
      }

      SetStopLossTakeProfit(signal, signal.isBuySignal);
      signal.strategy = S_RETEST_SR;
      signal.comment = "SR Retest (Bollinger)";
      signal.confirmations = 1;
      signal.valid = true;
      
      return true;
   }

   bool DetectBreakoutSignal(STradeSignal &signal) {
      signal.valid = false;
      const int lookbackBars = 20;
      
      int highestBar = iHighest(_Symbol, _Period, MODE_HIGH, lookbackBars, 1);
      int lowestBar = iLowest(_Symbol, _Period, MODE_LOW, lookbackBars, 1);
      
      if(highestBar == -1 || lowestBar == -1)
         return false;
         
      double rangeHigh = iHigh(_Symbol, _Period, highestBar);
      double rangeLow = iLow(_Symbol, _Period, lowestBar);
      
      double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      
      if(ask > rangeHigh) {
         signal.isBuySignal = true;
         signal.price = ask;
         signal.strength = 85.0;
      }
      else if(bid < rangeLow) {
         signal.isBuySignal = false;
         signal.price = bid;
         signal.strength = 85.0;
      }
      else {
         return false;
      }

      SetStopLossTakeProfit(signal, signal.isBuySignal);
      signal.strategy = S_BREAKOUT_RANGE;
      signal.comment = StringFormat("Breakout (%.4f-%.4f)", rangeLow, rangeHigh);
      signal.confirmations = 1;
      signal.valid = true;
      
      return true;
   }

   bool DetectPullbackEMASignal(STradeSignal &signal) {
      signal.valid = false;
      
      double ema20[];
      if(CopyBuffer(emaHandle, 0, 0, 1, ema20) <= 0)
         return false;

      double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      
      if(bid < ema20[0] - _Point * 10) {
         signal.isBuySignal = true;
         signal.price = ask;
         signal.strength = 65.0;
      }
      else if(ask > ema20[0] + _Point * 10) {
         signal.isBuySignal = false;
         signal.price = bid;
         signal.strength = 65.0;
      }
      else {
         return false;
      }

      SetStopLossTakeProfit(signal, signal.isBuySignal);
      signal.strategy = S_PULLBACK_EMA;
      signal.comment = "Pullback EMA20";
      signal.confirmations = 1;
      signal.valid = true;
      
      return true;
   }

   bool DetectScalpingSignal(STradeSignal &signal) {
      signal.valid = false;
      
      if(GetSpreadPips() > 1.5)
         return false;

      double lastPrice = SymbolInfoDouble(_Symbol, SYMBOL_LAST);
      double prevClose = iClose(_Symbol, _Period, 1);
      
      if(lastPrice > prevClose + _Point * 3) {
         signal.isBuySignal = true;
         signal.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         signal.strength = 60.0;
      }
      else if(lastPrice < prevClose - _Point * 3) {
         signal.isBuySignal = false;
         signal.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         signal.strength = 60.0;
      }
      else {
         return false;
      }

      double atrValue = GetCurrentATR();
      if(atrValue <= 0) atrValue = _Point * 30;
      
      if(signal.isBuySignal) {
         signal.sl = signal.price - (atrValue * 1.0);
         signal.tp = signal.price + (atrValue * 1.5);
      }
      else {
         signal.sl = signal.price + (atrValue * 1.0);
         signal.tp = signal.price - (atrValue * 1.5);
      }
      
      signal.strategy = S_SCALPING;
      signal.comment = "Scalping Quick Trade";
      signal.confirmations = 1;
      signal.valid = true;
      
      return true;
   }

   //+------------------------------------------------------------------+
   //| Détection des signaux Ichimoku                                   |
   //+------------------------------------------------------------------+
   bool DetectIchimokuSignal(STradeSignal &signal) {
      signal.valid = false;
      
      // 1. Récupération des composantes Ichimoku
      double tenkan[], kijun[], spanA[], spanB[];
      if (CopyBuffer(ichimokuHandle, 0, 1, 1, tenkan) <= 0) return false;  // Tenkan-sen
      if (CopyBuffer(ichimokuHandle, 1, 1, 1, kijun) <= 0) return false;   // Kijun-sen
      if (CopyBuffer(ichimokuHandle, 2, 26, 1, spanA) <= 0) return false;  // Senkou Span A
      if (CopyBuffer(ichimokuHandle, 3, 26, 1, spanB) <= 0) return false;  // Senkou Span B
      
      double price = iClose(_Symbol, _Period, 0);
      
      // 2. Conditions d'achat/vente
      bool isAboveCloud = (price > spanA[0] && price > spanB[0]);
      bool isBelowCloud = (price < spanA[0] && price < spanB[0]);
      bool tenkanAboveKijun = (tenkan[0] > kijun[0]);
      bool tenkanBelowKijun = (tenkan[0] < kijun[0]);
      
      if (isAboveCloud && tenkanAboveKijun) {
         signal.isBuySignal = true;
         signal.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         signal.strategy = S_ICHIMOKU;
         signal.comment = "Ichimoku: Bullish Trend";
         signal.strength = 85.0; // Forte confiance
      } 
      else if (isBelowCloud && tenkanBelowKijun) {
         signal.isBuySignal = false;
         signal.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         signal.strategy = S_ICHIMOKU;
         signal.comment = "Ichimoku: Bearish Trend";
         signal.strength = 85.0;
      }
      
      if (signal.valid) {
         SetStopLossTakeProfit(signal, signal.isBuySignal);
         signal.confirmations = 3; // Très fiable
         return true;
      }
      return false;
   }

   //+------------------------------------------------------------------+
   //| Détection des motifs Price Action                                 |
   //+------------------------------------------------------------------+
   bool DetectPriceActionSignal(STradeSignal &signal) {
      signal.valid = false;
      
      // 1. Engulfing haussier/baissier
      double open1 = iOpen(_Symbol, _Period, 1);
      double close1 = iClose(_Symbol, _Period, 1);
      double open2 = iOpen(_Symbol, _Period, 2);
      double close2 = iClose(_Symbol, _Period, 2);
      
      bool bullishEngulfing = (close1 > open1 && close2 < open2 && close1 > open2 && open1 < close2);
      bool bearishEngulfing = (close1 < open1 && close2 > open2 && close1 < open2 && open1 > close2);
      
      // 2. Pinbar (rejet de prix)
      double high1 = iHigh(_Symbol, _Period, 1);
      double low1 = iLow(_Symbol, _Period, 1);
      bool bullishPinbar = (close1 > open1 && (high1 - close1) > 2 * (close1 - open1));
      bool bearishPinbar = (close1 < open1 && (low1 - close1) > 2 * (open1 - close1));
      
      // 3. Inside Bar (consolidation)
      double high2 = iHigh(_Symbol, _Period, 2);
      double low2 = iLow(_Symbol, _Period, 2);
      bool insideBar = (high1 < high2 && low1 > low2);
      
      if (bullishEngulfing || bullishPinbar) {
         signal.isBuySignal = true;
         signal.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         signal.strategy = S_PRICE_ACTION;
         signal.comment = "Price Action: Bullish Signal";
         signal.strength = 75.0;
      } 
      else if (bearishEngulfing || bearishPinbar) {
         signal.isBuySignal = false;
         signal.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         signal.strategy = S_PRICE_ACTION;
         signal.comment = "Price Action: Bearish Signal";
         signal.strength = 75.0;
      }
      
      if (signal.valid) {
         SetStopLossTakeProfit(signal, signal.isBuySignal);
         signal.confirmations = 2; // Moins prioritaire qu'un breakout
         return true;
      }
      return false;
   }

   bool IsTradingHours() {
      if(!EnableTradingHours) return true;
      
      MqlDateTime timeStruct;
      TimeCurrent(timeStruct);
      int currentHour = timeStruct.hour;
      
      return (currentHour >= TradingStartHour && currentHour < TradingEndHour);
   }

private:
   string GetIndicatorName(int handle) {
      if(handle == macdHandle) return "MACD";
      if(handle == rsiHandle) return "RSI";
      if(handle == atrHandle) return "ATR";
      if(handle == adxHandle) return "ADX";
      if(handle == bbHandle) return "Bollinger Bands";
      if(handle == emaHandle) return "EMA 20";
      if(handle == ema200Handle) return "EMA 200";
      if(handle == superTrendHandle) return "SuperTrend";
      if(handle == ichimokuHandle) return "Ichimoku";
      return "Unknown Indicator";
   }
};

//+------------------------------------------------------------------+
//| Classe CTradeManager – Gestion des positions                     |
//+------------------------------------------------------------------+
/* =====================================================
   CLASS CTradeManager - Gestion avancée des trades
   Version : 4.1 (Stable)
   Fonctionnalités :
   - Exécution sécurisée des trades
   - Gestion des positions (SL mobile, breakeven)
   - Tracking précis des performances par stratégie
   - Protection contre les doublons
   ===================================================== */
class CTradeManager {
private:
   // ================ VARIABLES MEMBRES ================ //
   ulong m_lastProcessedTicket;  // Dernier ticket traité
   CRiskManager* m_riskManager;  // Gestionnaire de risques
   CTrade m_trade;               // Objet de trading MT5

   // ================ METHODES INTERNES ================ //

   /**
    * Gère le trailing stop dynamique
    * @param ticket Identifiant de la position
    * @param type Type de position (BUY/SELL)
    * @param entry Prix d'entrée
    * @param sl Niveau actuel du stop-loss
    */
   void ManageTrailingStop(ulong ticket, ENUM_POSITION_TYPE type, double entry, double sl) {
      double atr = strategyManager.GetCurrentATR();
      if(atr <= 0) return;

      double newSL = sl;
      double currentPrice = (type == POSITION_TYPE_BUY) ? 
                          SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
                          SymbolInfoDouble(_Symbol, SYMBOL_ASK);

      // Calcul du nouveau SL basé sur la volatilité (ATR)
      if(type == POSITION_TYPE_BUY) {
         newSL = MathMax(sl, currentPrice - (atr * 1.2));
      } else {
         newSL = MathMin(sl, currentPrice + (atr * 1.2));
      }

      // Applique seulement si changement significatif
      if(MathAbs(newSL - sl) > _Point * 2) {
         m_trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP));
      }
   }

   /**
    * Ferme partiellement une position selon les règles ATR
    */
   void ManagePartialClose(ulong ticket, ENUM_POSITION_TYPE type, double entry, double sl, double volume) {
      double atr = strategyManager.GetCurrentATR();
      if(atr <= 0) return;

      double currentPrice = (type == POSITION_TYPE_BUY) ? 
                          SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
                          SymbolInfoDouble(_Symbol, SYMBOL_ASK);

      // Vérifie si le prix a atteint le seuil de fermeture partielle
      if(MathAbs(currentPrice - entry) < atr * PartialCloseATRMultiplier) return;

      // Calcule le volume à fermer
      double step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
      int digits = (step > 0) ? (int)MathRound(-MathLog10(step)) : 2;
      double volClose = NormalizeDouble(volume * (PARTIAL_CLOSE_PERCENT / 100.0), digits);

      if(volClose < SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN)) return;

      // Exécute la fermeture partielle
      if(m_trade.PositionClosePartial(ticket, volClose) && EnableNotifications) {
         gNotifier.SendNotification(StringFormat("🔻 Fermeture partielle %.2f lots (Ticket %I64d)", volClose, ticket));
      }
   }

   /**
    * Déclenche le breakeven selon les paramètres
    */
   void ManageBreakeven(ulong ticket, ENUM_POSITION_TYPE type, double entry, double sl) {
      if(!EnableBreakeven) return;
      
      double atr = strategyManager.GetCurrentATR();
      if(atr <= 0) return;
      
      double currentPrice = (type == POSITION_TYPE_BUY) ? 
                          SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
                          SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      
      // Vérifie si le seuil de breakeven est atteint
      if(MathAbs(currentPrice - entry) < atr * BreakevenTriggerATR) return;
      
      // Calcule le nouveau SL (entry + buffer)
      double newSL = entry + ((type == POSITION_TYPE_BUY) ? 
                             (atr * BreakevenATRMultiplier) : 
                             (-atr * BreakevenATRMultiplier));
      
      // Vérifie si le SL actuel est déjà meilleur
      if((type == POSITION_TYPE_BUY && sl >= newSL) || 
         (type == POSITION_TYPE_SELL && sl <= newSL)) return;
      
      // Applique la modification
      if(!m_trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP))) {
         Print("Erreur breakeven: ", GetLastError());
      } else if(EnableNotifications) {
         gNotifier.SendNotification(StringFormat("🔄 Breakeven activé @ %.5f (Ticket %I64d)", newSL, ticket));
      }
   }

   /**
    * Valide la cohérence des niveaux de prix
    */
   bool ValidatePrices(double price, double sl, double tp, bool isBuy) {
      if(isBuy && (sl >= price || tp <= price)) {
         Print("Erreur validation: SL/TP invalide pour BUY");
         return false;
      }
      if(!isBuy && (sl <= price || tp >= price)) {
         Print("Erreur validation: SL/TP invalide pour SELL");
         return false;
      }
      return true;
   }

public:
   // ================ CONSTRUCTEUR ================ //
    CTradeManager(CRiskManager *mgr) : m_riskManager(mgr), m_lastProcessedTicket(0) 
   {
      m_trade.SetExpertMagicNumber(MagicNumber);
      m_trade.SetMarginMode();
      m_trade.SetTypeFillingBySymbol(_Symbol);
      m_trade.SetDeviationInPoints(Slippage);
      
      this.InitializeTradeTracking(); // Appel avec 'this' pour clarification
      Print("[CTradeManager] Initialisation complète");
   }
   
     // ================= METHODE INITIALIZE ================= //
   /**
    * Initialise le suivi des trades depuis l'historique
    * @warning Doit être appelée avant toute utilisation de la classe
    */
   void InitializeTradeTracking() 
   {
      // 1. Charge l'historique complet
      HistorySelect(0, TimeCurrent());
      
      // 2. Récupère le dernier ticket
      int totalDeals = HistoryDealsTotal();
      if(totalDeals > 0) 
      {
         m_lastProcessedTicket = HistoryDealGetTicket(totalDeals-1);
         Print("[Tracking] Initialisé. Dernier ticket: ", m_lastProcessedTicket);
      }
      else
      {
         Print("[Tracking] Aucun trade dans l'historique");
         m_lastProcessedTicket = 0; // Initialisation explicite
      }
   }

   /**
    * Traite les résultats des trades (MISE À JOUR CRITIQUE)
    */
   void ProcessTradeResults() {
      HistorySelect(0, TimeCurrent());
      int total = HistoryDealsTotal();
      
      for(int i = 0; i < total; i++) {
         ulong ticket = HistoryDealGetTicket(i);
         if(ticket <= m_lastProcessedTicket) continue;
         
         // Filtre les deals de sortie avec notre MagicNumber
         if(HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT && 
            HistoryDealGetInteger(ticket, DEAL_MAGIC) == MagicNumber) 
         {
            string comment = HistoryDealGetString(ticket, DEAL_COMMENT);
            double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT) +
                           HistoryDealGetDouble(ticket, DEAL_SWAP) +
                           HistoryDealGetDouble(ticket, DEAL_COMMISSION);

            // Attribution à la stratégie
            for(int j = 0; j < STRATEGY_COUNT; j++) {
               if(StringFind(comment, EnumToString(strategyPerformance[j].strategy)) != -1) {
                  strategyPerformance[j].totalTrades++;
                  if(profit >= 0) strategyPerformance[j].wins++;
                  else strategyPerformance[j].losses++;
                  
                  Print("[Stats] ", EnumToString(strategyPerformance[j].strategy), 
                        " | Trades: ", strategyPerformance[j].totalTrades,
                        " | Wins: ", strategyPerformance[j].wins,
                        " | Losses: ", strategyPerformance[j].losses);
                  break;
               }
            }
         }
         m_lastProcessedTicket = ticket;
      }
   }

   /**
    * Vérifie si un nouveau trade est autorisé
    */
   bool CanOpenNewPosition(const string sym) {
      int openCnt = 0;
      for(int i = PositionsTotal() - 1; i >= 0; i--) {
         ulong ticket = PositionGetTicket(i);
         if(!PositionSelectByTicket(ticket)) continue;
         
         if(PositionGetString(POSITION_SYMBOL) == sym && 
            (int)PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
            openCnt++;
         }
      }

      if(openCnt >= MAX_POSITIONS_PER_SYMBOL) {
         Print("[Limit] Max positions atteint (", MAX_POSITIONS_PER_SYMBOL, ") pour ", sym);
         ManagePositions();
         return false;
      }
      return true;
   }

   
 
/**
 * Exécute un trade en suivant strictement les règles de gestion
 * @param signal Structure contenant tous les détails du trade
 * @return bool - true si le trade a été exécuté avec succès
 */
bool ExecuteTrade(const STradeSignal &signal) {
   // ================ PHASE 1 : VÉRIFICATIONS PRÉ-TRADE ================ //
   
   // 1.1 Validation du signal
   if(!signal.valid) {
      Print("[EXEC] Abandon - Signal invalide");
      return false;
   }

   // 1.2 Vérification des limites de positions
   if(!CanOpenNewPosition(_Symbol)) {
      Print("[EXEC] Abandon - Limite de positions atteinte pour ", _Symbol);
      return false;
   }

   // 1.3 Validation des niveaux de prix
   if(!ValidatePrices(signal.price, signal.sl, signal.tp, signal.isBuySignal)) {
      Print("[EXEC] Abandon - Niveaux SL/TP invalides");
      return false;
   }

   // 1.4 Respect du délai minimum entre trades
   if(!m_riskManager.CheckMinTimeBetweenTrades(MinMinutesBetweenTrades)) {
      Print("[EXEC] Abandon - Délai minimum entre trades non respecté");
      return false;
   }

   // ================ PHASE 2 : PRÉPARATION DU TRADE ================ //

   // 2.1 Calcul de la taille de position
   double lots = m_riskManager.CalculatePositionSize(signal.price, signal.sl);
   if(lots <= 0.0) {
      Print("[EXEC] Abandon - Calcul des lots invalide (", lots, ")");
      return false;
   }

   // 2.2 Détermination du type d'ordre
   ENUM_ORDER_TYPE type = signal.isBuySignal ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
   
   // ================ PHASE 3 : EXÉCUTION DU TRADE ================ //

   if(m_trade.PositionOpen(_Symbol, type, lots, signal.price, signal.sl, signal.tp, signal.comment)) {
      // 3.1 Suivi immédiat du trade
      ulong ticket = m_trade.ResultOrder();
      Print("[EXEC] Succès - Ticket:", ticket, 
            " | Lots:", lots, 
            " | Prix:", signal.price,
            " | SL:", signal.sl, 
            " | TP:", signal.tp);

      // 3.2 Mise à jour des performances (CRITIQUE)
      ProcessTradeResults();
      
      // 3.3 Gestion de la martingale
      if(EnableMartingale) {
         g_MartingaleStep = (g_ConsecutiveLosses > 0 && g_MartingaleStep < MaxMartingaleSteps) ? 
                           g_MartingaleStep + 1 : 0;
         g_LastLotSize = lots;
         Print("[MARTINGALE] Step:", g_MartingaleStep, " | Lots:", g_LastLotSize);
      }

      // 3.4 Notification
      if(EnableNotifications) {
         string direction = signal.isBuySignal ? "ACHAT" : "VENTE";
         string msg = StringFormat("%s %s %.2f lots à %.5f\nSL: %.5f | TP: %.5f\nStratégie: %s",
                                 direction, _Symbol, lots, signal.price, 
                                 signal.sl, signal.tp, signal.comment);
         gNotifier.SendNotification(msg);
      }

      // 3.5 Mise à jour du timer
      m_riskManager.UpdateTradeResult(0);
      
      return true;
   } 
   else {
      // Gestion des erreurs détaillée (version corrigée)
      int err = GetLastError();
      string errDesc;
      
      // Conversion du code d'erreur en description
      switch(err) {
         case 135: errDesc = "Requote"; break;
         case 136: errDesc = "Off quotes"; break;
         case 146: errDesc = "Trade context is busy"; break;
         default: errDesc = "Erreur " + IntegerToString(err);
      }
      
      Print("[EXEC] Échec - ", errDesc);
      
      // Tentative de récupération pour certaines erreurs
      if(err == 135 || err == 136) { // Requote/Off quotes
         Print("[EXEC] Nouvelle tentative après requote...");
         Sleep(100);
         return ExecuteTrade(signal); // Recall avec mêmes paramètres
      }
      
      return false;
   }
}

//-------------------- FIN FONCTION ---------//
   /**
    * Gère toutes les positions ouvertes
    */
   void ManagePositions() {
      for(int i = PositionsTotal() - 1; i >= 0; i--) {
         ulong ticket = PositionGetTicket(i);
         if(ticket == 0) continue;

         if(PositionSelectByTicket(ticket) && 
            PositionGetString(POSITION_SYMBOL) == _Symbol && 
            (int)PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
            
            ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            double entry = PositionGetDouble(POSITION_PRICE_OPEN);
            double sl = PositionGetDouble(POSITION_SL);
            
            ManageTrailingStop(ticket, type, entry, sl);
            ManagePartialClose(ticket, type, entry, sl, PositionGetDouble(POSITION_VOLUME));
            ManageBreakeven(ticket, type, entry, sl);
         }
      }
   }
};
//===================================================
// SECTION 6bis : INSTANCES GLOBALES
//===================================================
CRiskManager gRiskManager(MaxDailyLossPercent, MaxLossPercent, 
                         MaxConsecutiveLosses, PauseAfterLosses, PauseDurationMinutes);

CNotificationManager gNotifier(TelegramToken, TelegramChatId, EmailAddress);

CTradeManager tradeManager(&gRiskManager);

CStrategyManager strategyManager;
CTradeManager gTradeManager(&gRiskManager);  // <-- AJOUTEZ CETTE LIGNE

//===================================================
// SECTION 6ter : NOUVELLES FONCTIONS
//===================================================
/**
 * Détermine l'état de volatilité du marché
 */
ENUM_MARKET_CONDITION AnalyzeMarketCondition() {
   double atr = strategyManager.GetCurrentATR();
   double atrPercent = (atr / SymbolInfoDouble(_Symbol, SYMBOL_BID)) * 100;
   
   if(atrPercent < 0.1) return MARKET_CALM;
   else if(atrPercent < 0.3) return MARKET_MODERATE;
   else return MARKET_VOLATILE;
}

/** * Ajuste les paramètres selon la volatilité du marché  */
void AdjustParametersByMarketCondition(ENUM_MARKET_CONDITION condition) {
   switch(condition) {
      case MARKET_CALM:
         g_SLatrMult = 2.0;
         g_TPatrMult = 1.5;
         g_SuperTrendMultiplier = 2.0;
         break;
      case MARKET_MODERATE:
         g_SLatrMult = 3.0;
         g_TPatrMult = 2.0;
         g_SuperTrendMultiplier = 3.0;
         break;
      case MARKET_VOLATILE:
         g_SLatrMult = 4.0;
         g_TPatrMult = 3.0;
         g_SuperTrendMultiplier = 4.0;
         break;
   }
}

/**
 * Vérifie la cohérence entre le signal et la tendance
 */
bool CheckTrendConsistency(bool isBuySignal) {
   bool trendBullish = IsTrendBullish(_Period);
   
   if(isBuySignal && !trendBullish) {
      Print("Impossible de trader contre la tendance du Marché (Achat en tendance baissière)");
      return false;
   }
   else if(!isBuySignal && trendBullish) {
      Print("Impossible de trader contre la tendance du Marché (Vente en tendance haussière)");
      return false;
   }
   
   return true;
}

/**
 * Détermine si la tendance est haussière sur le timeframe donné
 */
bool IsTrendBullish(ENUM_TIMEFRAMES tf) {
   int barsToAnalyze = 50; // Valeur par défaut pour M1
   
   switch(tf) {
      case PERIOD_M1:  barsToAnalyze = 50; break;
      case PERIOD_M5:  barsToAnalyze = 30; break;
      case PERIOD_M15: barsToAnalyze = 20; break;
      case PERIOD_M30: barsToAnalyze = 15; break;
      case PERIOD_H1:  barsToAnalyze = 10; break;
      case PERIOD_H4:  barsToAnalyze = 6;  break;
      default:         barsToAnalyze = 50; break;
   }
   
   double sum = 0;
   for(int i = 1; i <= barsToAnalyze; i++) {
      double close1 = iClose(_Symbol, tf, i);
      double close2 = iClose(_Symbol, tf, i+1);
      sum += close1 - close2;
   }
   
   return sum > 0;
}


//===================================================
// SECTION 7 : DASHBOARD GRAPHIQUE AMELIORE
//===================================================
void DeleteDashboard() {
   string prefix = "DASH_";
   for(int i = ObjectsTotal(0) - 1; i >= 0; i--) {
      string name = ObjectName(0, i);
      if(StringFind(name, prefix) == 0) {
         ObjectDelete(0, name);
      }
   }
}

void DisplayLabel(const string name, const string text, int x, int y, color col, int fontSize = 10, bool bold = false) {
   string objName = "DASH_" + name;
   ObjectCreate(0, objName, OBJ_LABEL, 0, 0, 0);
   ObjectSetInteger(0, objName, OBJPROP_CORNER, 0);
   ObjectSetInteger(0, objName, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, objName, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, fontSize);
   ObjectSetInteger(0, objName, OBJPROP_COLOR, col);
   ObjectSetInteger(0, objName, OBJPROP_SELECTABLE, false);
   ObjectSetInteger(0, objName, OBJPROP_HIDDEN, false);
   ObjectSetString(0, objName, OBJPROP_TEXT, text);
   if(bold) ObjectSetString(0, objName, OBJPROP_FONT, "Arial Black");
}

void DrawProgressBar(const string name, int x, int y, double percent, color good, color bad, int width = 100, int height = 15) {
   percent = MathMax(0.0, MathMin(percent, 100.0));
   
   // Fond de la barre
   ObjectCreate(0, "DASH_" + name + "_BG", OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, "DASH_" + name + "_BG", OBJPROP_CORNER, 0);
   ObjectSetInteger(0, "DASH_" + name + "_BG", OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, "DASH_" + name + "_BG", OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, "DASH_" + name + "_BG", OBJPROP_XSIZE, width);
   ObjectSetInteger(0, "DASH_" + name + "_BG", OBJPROP_YSIZE, height);
   ObjectSetInteger(0, "DASH_" + name + "_BG", OBJPROP_BGCOLOR, clrDimGray);
   ObjectSetInteger(0, "DASH_" + name + "_BG", OBJPROP_BORDER_TYPE, BORDER_FLAT);
   ObjectSetInteger(0, "DASH_" + name + "_BG", OBJPROP_BORDER_COLOR, clrGray);
   ObjectSetInteger(0, "DASH_" + name + "_BG", OBJPROP_HIDDEN, false);
   
   // Partie remplie
   int fillWidth = (int)(percent / 100.0 * width);
   ObjectCreate(0, "DASH_" + name + "_FILL", OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, "DASH_" + name + "_FILL", OBJPROP_CORNER, 0);
   ObjectSetInteger(0, "DASH_" + name + "_FILL", OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, "DASH_" + name + "_FILL", OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, "DASH_" + name + "_FILL", OBJPROP_XSIZE, fillWidth);
   ObjectSetInteger(0, "DASH_" + name + "_FILL", OBJPROP_YSIZE, height);
   ObjectSetInteger(0, "DASH_" + name + "_FILL", OBJPROP_BGCOLOR, percent >= 50 ? good : bad);
   ObjectSetInteger(0, "DASH_" + name + "_FILL", OBJPROP_HIDDEN, false);
   
   // Texte du pourcentage
   DisplayLabel(name + "_TEXT", StringFormat("%.1f%%", percent), x + width + 5, y, TEXT_COLOR, 9);
}

void CreateButton(const string name, const string caption, int x, int y, int w, int h, color bgColor, color textColor = clrWhite) {
   string objName = "DASH_" + name;
   ObjectCreate(0, objName, OBJ_BUTTON, 0, 0, 0);
   ObjectSetInteger(0, objName, OBJPROP_CORNER, 0);
   ObjectSetInteger(0, objName, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, objName, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, objName, OBJPROP_XSIZE, w);
   ObjectSetInteger(0, objName, OBJPROP_YSIZE, h);
   ObjectSetInteger(0, objName, OBJPROP_BGCOLOR, bgColor);
   ObjectSetInteger(0, objName, OBJPROP_COLOR, textColor);
   ObjectSetInteger(0, objName, OBJPROP_BORDER_COLOR, clrGray);
   ObjectSetInteger(0, objName, OBJPROP_SELECTABLE, false);
   ObjectSetInteger(0, objName, OBJPROP_HIDDEN, false);
   ObjectSetString(0, objName, OBJPROP_TEXT, caption);
   ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, 9);
}

//+------------------------------------------------------------------+
//| Fonction pour obtenir les statistiques du jour                   |
//+------------------------------------------------------------------+
void GetTodayStats(int &total, int &wins, int &losses, double &profit) {
    MqlDateTime todayStruct;
    TimeCurrent(todayStruct);
    todayStruct.hour = 0;
    todayStruct.min = 0;
    todayStruct.sec = 0;
    datetime dayStart = StructToTime(todayStruct);
    datetime dayEnd = dayStart + 86400;

    total = wins = losses = 0;
    profit = 0.0;

    // Remplacement de la hashmap : deux tableaux parallèles
    long   positionIDs[];
    double positionProfits[];

    ArrayResize(positionIDs, 0);
    ArrayResize(positionProfits, 0);

    HistorySelect(dayStart, dayEnd);
    int totalDeals = HistoryDealsTotal();

    for (int i = 0; i < totalDeals; i++) {
        ulong dealTicket = HistoryDealGetTicket(i);

        long dealMagic = HistoryDealGetInteger(dealTicket, DEAL_MAGIC);
        if (dealMagic != MagicNumber && dealMagic != 0)
            continue;

        ENUM_DEAL_ENTRY entryType = (ENUM_DEAL_ENTRY)HistoryDealGetInteger(dealTicket, DEAL_ENTRY);
        if (entryType != DEAL_ENTRY_OUT)
            continue;

        long posId = (long)HistoryDealGetInteger(dealTicket, DEAL_POSITION_ID);

        // Cherche si la position est déjà présente
        int index = -1;
        for (int j = 0; j < ArraySize(positionIDs); j++) {
            if (positionIDs[j] == posId) {
                index = j;
                break;
            }
        }

        double dealProfit     = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
        double dealCommission = HistoryDealGetDouble(dealTicket, DEAL_COMMISSION);
        double dealSwap       = HistoryDealGetDouble(dealTicket, DEAL_SWAP);
        double netProfit      = dealProfit + dealCommission + dealSwap;

        if (index == -1) {
            // Nouvelle position
            ArrayResize(positionIDs, ArraySize(positionIDs) + 1);
            ArrayResize(positionProfits, ArraySize(positionProfits) + 1);
            positionIDs[ArraySize(positionIDs) - 1] = posId;
            positionProfits[ArraySize(positionProfits) - 1] = netProfit;
        } else {
            // Ajout au profit existant
            positionProfits[index] += netProfit;
        }
    }

    // Traitement final
    for (int i = 0; i < ArraySize(positionIDs); i++) {
        double netProfit = positionProfits[i];

        if (MathAbs(netProfit) < 0.00001) {
            PrintFormat("[Trade ID %I64d] → NEUTRE (ignoré)", positionIDs[i]);
            continue;
        }

        total++;
        profit += netProfit;

        if (netProfit > 0) {
            wins++;
            PrintFormat("[Trade ID %I64d] → GAGNANT (%.2f)", positionIDs[i], netProfit);
        } else {
            losses++;
            PrintFormat("[Trade ID %I64d] → PERDANT (%.2f)", positionIDs[i], netProfit);
        }
    }

    PrintFormat("[Résumé] Total trades: %d (Attendu: 82)", total);
    PrintFormat("[Résumé] Trades gagnants: %d (Attendu: 49)", wins);
    PrintFormat("[Résumé] Trades perdants: %d (Attendu: 33)", losses);
    PrintFormat("[Résumé] Profit total: %.2f", profit);
}


//---------------------------------------------//


// Fonction utilitaire pour vérifier les trades à profit nul
void CheckNeutralTrades() {
   datetime dayStart = StringToTime(TimeToString(TimeCurrent(), TIME_DATE));
   datetime dayEnd = dayStart + 86400;
   int neutralCount = 0;
   
   HistorySelect(dayStart, dayEnd);
   int totalDeals = HistoryDealsTotal();
   
   for(int i = 0; i < totalDeals; i++) {
      ulong ticket = HistoryDealGetTicket(i);
      long magic = HistoryDealGetInteger(ticket, DEAL_MAGIC);
      
      if((magic == MagicNumber || magic == 0) && 
         HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT) {
         
         double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
         double commission = HistoryDealGetDouble(ticket, DEAL_COMMISSION);
         double swap = HistoryDealGetDouble(ticket, DEAL_SWAP);
         double net = profit + commission + swap;
         
         if(MathAbs(net) < 0.00001) { // Profit net quasi nul
            neutralCount++;
            PrintFormat("Trade neutre #%d: Ticket=%I64d Profit=%.5f", neutralCount, ticket, net);
         }
      }
   }
   Print("Total trades neutres: ", neutralCount);
}


//+------------------------------------------------------------------+
//| Dessine une courbe de performance simplifiée                     |
//+------------------------------------------------------------------+
void DrawEquityCurve(int x, int y, int width, int height) {
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double maxVal = MathMax(equity, balance);
   double minVal = MathMin(equity, balance);
   
   // Crée un cadre pour le graphique
   ObjectCreate(0, "DASH_EQUITY_FRAME", OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, "DASH_EQUITY_FRAME", OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, "DASH_EQUITY_FRAME", OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, "DASH_EQUITY_FRAME", OBJPROP_XSIZE, width);
   ObjectSetInteger(0, "DASH_EQUITY_FRAME", OBJPROP_YSIZE, height);
   ObjectSetInteger(0, "DASH_EQUITY_FRAME", OBJPROP_BGCOLOR, clrBlack);
   ObjectSetInteger(0, "DASH_EQUITY_FRAME", OBJPROP_BORDER_COLOR, clrGray);
   ObjectSetInteger(0, "DASH_EQUITY_FRAME", OBJPROP_HIDDEN, false);
   
   // Efface l'ancienne ligne
   ObjectDelete(0, "DASH_EQUITY_LINE");
   
   // Dessine une ligne pour l'equity
   ObjectCreate(0, "DASH_EQUITY_LINE", OBJ_TREND, 0, 0, 0);
   ObjectSetInteger(0, "DASH_EQUITY_LINE", OBJPROP_TIME, 0, TimeCurrent() - PeriodSeconds() * width / 50);
   ObjectSetDouble(0, "DASH_EQUITY_LINE", OBJPROP_PRICE, 0, y + height);
   ObjectSetInteger(0, "DASH_EQUITY_LINE", OBJPROP_TIME, 1, TimeCurrent());
   ObjectSetDouble(0, "DASH_EQUITY_LINE", OBJPROP_PRICE, 1, 
                  y + height - (height * (equity - minVal) / (maxVal - minVal)));
   ObjectSetInteger(0, "DASH_EQUITY_LINE", OBJPROP_COLOR, equity >= balance ? POSITIVE_COLOR : NEGATIVE_COLOR);
   ObjectSetInteger(0, "DASH_EQUITY_LINE", OBJPROP_WIDTH, 2);
   ObjectSetInteger(0, "DASH_EQUITY_LINE", OBJPROP_HIDDEN, false);
}

//+------------------------------------------------------------------+
//| Mise à jour du dashboard avec toutes les informations            |
//+------------------------------------------------------------------+
void UpdateDashboard() {
    RefreshStrategyStats(); // 🔄 indispensable pour mettre à jour les stats

   // 1. Fond du Dashboard
   ObjectCreate(0, "DASH_BG", OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, "DASH_BG", OBJPROP_BGCOLOR, PANEL_COLOR);
   ObjectSetInteger(0, "DASH_BG", OBJPROP_XDISTANCE, DashboardPosX);
   ObjectSetInteger(0, "DASH_BG", OBJPROP_YDISTANCE, DashboardPosY);
   ObjectSetInteger(0, "DASH_BG", OBJPROP_XSIZE, DashboardWidth);
   ObjectSetInteger(0, "DASH_BG", OBJPROP_YSIZE, DashboardHeight + 60);
   ObjectSetInteger(0, "DASH_BG", OBJPROP_BORDER_TYPE, BORDER_FLAT);
   ObjectSetInteger(0, "DASH_BG", OBJPROP_BORDER_COLOR, clrGray);
   ObjectSetInteger(0, "DASH_BG", OBJPROP_HIDDEN, false);

   // 2. Titre + Version
   DisplayLabel("TITLE", "DIAMOND PRO (Ver 40) - " + _Symbol + " " + EnumToString(_Period), 
               DashboardPosX + 10, DashboardPosY + 5, TEXT_COLOR, 12, true);

   // 3. Informations de compte
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double profit = equity - balance;
   color profitColor = profit >= 0 ? POSITIVE_COLOR : NEGATIVE_COLOR;

   int yOffset = 30;
   DisplayLabel("BALANCE", "Balance: $" + DoubleToString(balance, 2), DashboardPosX + 10, DashboardPosY + yOffset, TEXT_COLOR, 9);
   yOffset += 15;
   DisplayLabel("EQUITY", "Equity: $" + DoubleToString(equity, 2), DashboardPosX + 10, DashboardPosY + yOffset, TEXT_COLOR, 9);
   yOffset += 15;
   DisplayLabel("PROFIT", "P/L: $" + DoubleToString(profit, 2), DashboardPosX + 10, DashboardPosY + yOffset, profitColor, 9);
   yOffset += 15;

   // 4. Spread et statut EA
   double spread = strategyManager.GetSpreadPips();
   DisplayLabel("SPREAD", "Spread: " + DoubleToString(spread, 1) + " pips", DashboardPosX + 10, DashboardPosY + yOffset, TEXT_COLOR, 9);
   yOffset += 15;

   string statusText = "Status: " + (ea_is_active ? "ACTIVE" : "PAUSED");
   color statusColor = ea_is_active ? POSITIVE_COLOR : WARNING_COLOR;
   DisplayLabel("STATUS", statusText, DashboardPosX + 10, DashboardPosY + yOffset, statusColor, 9);
   yOffset += 20;

   // 5. Statistiques du jour
   int totalTrades, wins, losses;
   double dailyProfit;
   GetTodayStats(totalTrades, wins, losses, dailyProfit);
   double winRate = (totalTrades > 0) ? (wins * 100.0 / totalTrades) : 0;

   DisplayLabel("TODAY_TRADES", "Trades today: " + IntegerToString(totalTrades), DashboardPosX + 10, DashboardPosY + yOffset, TEXT_COLOR, 9);
   yOffset += 15;
   DisplayLabel("TODAY_WINS", "Wins today: " + IntegerToString(wins), DashboardPosX + 10, DashboardPosY + yOffset, POSITIVE_COLOR, 9);
   yOffset += 15;
   DisplayLabel("TODAY_LOSSES", "Losses today: " + IntegerToString(losses), DashboardPosX + 10, DashboardPosY + yOffset, NEGATIVE_COLOR, 9);
   yOffset += 15;
   DisplayLabel("TODAY_WINRATE", "Win rate: " + DoubleToString(winRate, 1) + "%", DashboardPosX + 10, DashboardPosY + yOffset, TEXT_COLOR, 9);
   yOffset += 15;
   DisplayLabel("TODAY_PROFIT", "Today P/L: $" + DoubleToString(dailyProfit, 2), DashboardPosX + 10, DashboardPosY + yOffset, 
               dailyProfit >= 0 ? POSITIVE_COLOR : NEGATIVE_COLOR, 9);
   yOffset += 20;

   // 6. Barre de progression Win Rate
   DrawProgressBar("WINRATE", DashboardPosX + 10, DashboardPosY + yOffset, winRate, POSITIVE_COLOR, NEGATIVE_COLOR, 100);
   yOffset += 25;

   // 7. Boutons PAUSE / CLOSE
   CreateButton("BTN_PAUSE", ea_is_active ? "⏸ PAUSE" : "▶ RESUME", 
             DashboardPosX + DashboardWidth - 220, DashboardPosY + yOffset - 25, 100, 20, 
             ea_is_active ? WARNING_COLOR : POSITIVE_COLOR);
   CreateButton("BTN_CLOSE", "❌ CLOSE ALL", 
             DashboardPosX + DashboardWidth - 110, DashboardPosY + yOffset - 25, 100, 20, 
             NEGATIVE_COLOR);

      // 8. Affichage des Stratégies
      //int yOffset = 330; // Ajustez cette valeur selon votre mise en page
      DisplayLabel("STRATEGIES_TITLE", "--- STRATEGIES PERFORMANCE ---", 
            DashboardPosX + 10, DashboardPosY + yOffset, TEXT_COLOR, 10, true);
      yOffset += 20;

   for(int i = 0; i < STRATEGY_COUNT; i++) {
   SStrategyPerformance perf = strategyPerformance[i];
   string stratName = EnumToString(perf.strategy);
   stratName = StringSubstr(stratName, 2); // Enlève le "S_" du nom
   
   color textColor = perf.enabled ? TEXT_COLOR : clrGray;
   string status = perf.enabled ? "ON" : "OFF";
   
   string labelText = StringFormat("%-15s: %s | Trades: %d | W: %d | L: %d | WR: %.1f%% | PnL: %.2f",
                                 stratName, status, perf.totalTrades, 
                                 perf.wins, perf.losses, perf.winRate, perf.totalProfit);
   
   DisplayLabel("STRAT_" + IntegerToString(i), labelText,
               DashboardPosX + 10, DashboardPosY + yOffset, textColor, 9);
   yOffset += 15;
}


   // 9. Courbe de performance (CORRIGÉE)
   int curveHeight = 80;
   int extraOffset = 60;  // ← décalage de 4 lignes
   int curveY = DashboardPosY + DashboardHeight - curveHeight - 10 + extraOffset;

   //double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   //double balance = AccountInfoDouble(ACCOUNT_BALANCE);

   ObjectCreate(0, "DASH_EQUITY_FRAME", OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, "DASH_EQUITY_FRAME", OBJPROP_XDISTANCE, DashboardPosX + 10);
   ObjectSetInteger(0, "DASH_EQUITY_FRAME", OBJPROP_YDISTANCE, curveY);
   ObjectSetInteger(0, "DASH_EQUITY_FRAME", OBJPROP_XSIZE, DashboardWidth - 20);
   ObjectSetInteger(0, "DASH_EQUITY_FRAME", OBJPROP_YSIZE, curveHeight);
   ObjectSetInteger(0, "DASH_EQUITY_FRAME", OBJPROP_BGCOLOR, clrBlack);
   ObjectSetInteger(0, "DASH_EQUITY_FRAME", OBJPROP_BORDER_COLOR, clrGray);
   ObjectSetInteger(0, "DASH_EQUITY_FRAME", OBJPROP_HIDDEN, false);

   ObjectDelete(0, "DASH_EQUITY_LINE");

   // ligne de tendance symbolique : on simule avec 2 points
   ObjectCreate(0, "DASH_EQUITY_LINE", OBJ_TREND, 0, TimeCurrent() - 3600, equity - 100, TimeCurrent(), equity);
   ObjectSetInteger(0, "DASH_EQUITY_LINE", OBJPROP_COLOR, POSITIVE_COLOR);
   ObjectSetInteger(0, "DASH_EQUITY_LINE", OBJPROP_WIDTH, 2);
   ObjectSetInteger(0, "DASH_EQUITY_LINE", OBJPROP_HIDDEN, false);
}


//+------------------------------------------------------------------+
//| Gestion des événements du dashboard                              |
//+------------------------------------------------------------------+
void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam) {
   // Gestion des événements du dashboard
   if(id == CHARTEVENT_OBJECT_CLICK) {
      if(sparam == "DASH_BTN_PAUSE") {
         ea_is_active = !ea_is_active;
         UpdateDashboard();
         if(EnableNotifications) {
            gNotifier.SendNotification("EA DIAMOND - " + (ea_is_active ? "RESUMED" : "PAUSED"));
         }
      }
      else if(sparam == "DASH_BTN_CLOSE") {
         if(MessageBox("Fermer TOUTES les positions ?", "CONFIRMATION", MB_YESNO|MB_ICONQUESTION) == IDYES) {
            CloseAllPositions();
            UpdateDashboard();
         }
      }
   }
   
   // Gestion du déplacement des SL et TP
   if(id == CHARTEVENT_OBJECT_DRAG) {
      // Vérifier si l'objet déplacé est un SL ou TP
      if(StringFind(sparam, "SL_") == 0 || StringFind(sparam, "TP_") == 0) {
         // Récupérer le ticket de la position
         string parts[];
         StringSplit(sparam, '_', parts);
         if(ArraySize(parts) >= 2) {
            ulong ticket = StringToInteger(parts[1]);
            if(PositionSelectByTicket(ticket)) {
               // Récupérer le nouveau niveau du SL ou TP
               double newLevel = ObjectGetDouble(0, sparam, OBJPROP_PRICE);
               
               // Modifier la position
               if(StringFind(sparam, "SL_") == 0) {
                  trade.PositionModify(ticket, newLevel, PositionGetDouble(POSITION_TP));
               } else {
                  trade.PositionModify(ticket, PositionGetDouble(POSITION_SL), newLevel);
               }
               
               // Recalculer les sorties partielles si nécessaire
               RecalculatePartialExits(ticket);
            }
         }
      }
   }
}

void RecalculatePartialExits(ulong ticket) {
   if(!PositionSelectByTicket(ticket)) return;
   
   double entry = PositionGetDouble(POSITION_PRICE_OPEN);
   double sl = PositionGetDouble(POSITION_SL);
   double tp = PositionGetDouble(POSITION_TP);
   double atr = strategyManager.GetCurrentATR();
   
   if(atr <= 0) return;
   
   // Recalculer les niveaux de sortie partielle basés sur le nouveau SL/TP
   double partialExitLevel;
   if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) {
      partialExitLevel = entry + (tp - entry) * (PartialClosePercent / 100.0);
   } else {
      partialExitLevel = entry - (entry - tp) * (PartialClosePercent / 100.0);
   }
   
   // Ici vous pouvez ajouter la logique pour modifier les ordres de sortie partielle
   // en fonction des nouveaux niveaux calculés
}

void RefreshStrategyStats() {
    // 1. Réinitialisation des statistiques
    for(int i = 0; i < STRATEGY_COUNT; i++) {
        strategyPerformance[i].totalTrades = 0;
        strategyPerformance[i].wins = 0;
        strategyPerformance[i].losses = 0;
        strategyPerformance[i].totalProfit = 0.0;
    }

    // 2. Configuration de la plage temporelle (24h)
    datetime dayStart = iTime(_Symbol, PERIOD_D1, 0);
    datetime dayEnd = TimeCurrent();
    HistorySelect(dayStart, dayEnd);

    // 3. Parcours de l'historique des trades
    int totalDeals = HistoryDealsTotal();
    Print("[DEBUG] Nombre total de deals dans l'historique : ", totalDeals);

    for(int i = 0; i < totalDeals; i++) {
        ulong ticket = HistoryDealGetTicket(i);
        if(ticket == 0) continue;

        // Vérification Magic Number
        long dealMagic = HistoryDealGetInteger(ticket, DEAL_MAGIC);
        if(dealMagic != MagicNumber) {
            Print("[DEBUG] Deal ignoré - Magic Number incorrect : ", dealMagic, " (Attendu: ", MagicNumber, ")");
            continue;
        }

        // Vérification type de deal (seulement les sorties)
        ENUM_DEAL_ENTRY entryType = (ENUM_DEAL_ENTRY)HistoryDealGetInteger(ticket, DEAL_ENTRY);
        if(entryType != DEAL_ENTRY_OUT) {
            Print("[DEBUG] Deal ignoré - Ce n'est pas une sortie (Entry Type: ", EnumToString(entryType), ")");
            continue;
        }

        // Calcul du profit net
        double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
        double swap = HistoryDealGetDouble(ticket, DEAL_SWAP);
        double commission = HistoryDealGetDouble(ticket, DEAL_COMMISSION);
        double netProfit = profit + swap + commission;

        // Récupération du commentaire
        string comment = HistoryDealGetString(ticket, DEAL_COMMENT);
        Print("[DEBUG] Analyse du deal #", i, " - Commentaire: ", comment, " - Profit: ", netProfit);

        // Attribution à la stratégie
        ENUM_STRATEGY strat = STRAT_NONE;
        if(StringFind(comment, "Checklist") != -1) strat = S_CHECKLIST;
        else if(StringFind(comment, "Breakout") != -1) strat = S_BREAKOUT_RANGE;
        else if(StringFind(comment, "Pullback") != -1) strat = S_PULLBACK_EMA;
        else if(StringFind(comment, "SuperTrend") != -1) strat = S_SUPERTREND;
        else if(StringFind(comment, "SR Retest") != -1) strat = S_RETEST_SR;
        else if(StringFind(comment, "Scalping") != -1) strat = S_SCALPING;
        else if(StringFind(comment, "Ichimoku") != -1) strat = S_ICHIMOKU;
        else if(StringFind(comment, "Price Action") != -1) strat = S_PRICE_ACTION;

        if(strat != STRAT_NONE) {
            int index = (int)strat - 1;
            strategyPerformance[index].totalTrades++;
            
            if(netProfit >= 0) {
                strategyPerformance[index].wins++;
            } else {
                strategyPerformance[index].losses++;
            }
            
            strategyPerformance[index].totalProfit += netProfit;
            strategyPerformance[index].winRate = (double)strategyPerformance[index].wins / 
                                               MathMax(1, strategyPerformance[index].totalTrades) * 100.0;
            
            Print("[SUCCESS] Trade attribué à ", EnumToString(strat), 
                  " | Résultat: ", (netProfit >= 0 ? "Gagnant" : "Perdant"),
                  " | Montant: ", netProfit);
        } else {
            Print("[WARNING] Stratégie non reconnue dans le commentaire : ", comment);
        }
    }

    // 4. Debug final
    Print("\n=== SYNTHESE DES STATISTIQUES ===");
    for(int i = 0; i < STRATEGY_COUNT; i++) {
        Print(i+1, ". ", EnumToString(strategyPerformance[i].strategy), 
              " | Trades: ", strategyPerformance[i].totalTrades,
              " | Gagnants: ", strategyPerformance[i].wins,
              " | Perdants: ", strategyPerformance[i].losses,
              " | WinRate: ", DoubleToString(strategyPerformance[i].winRate, 1), "%");
    }
}

//===================================================
// SECTION 8 : FONCTIONS PRINCIPALES DE L'EA
//===================================================
int OnInit() {
   // =====================================================
   // SECTION 1 : VÉRIFICATION DU SYMBOLE AUTORISÉ
   // =====================================================
   string allowedSymbols[] = {"EURUSDm","USDJPYm","GBPUSDm","XAUUSDm","GOLD","BTCUSDm"};
   bool symbolAllowed = false;
   
   // Vérification si le symbole actuel est dans la liste autorisée
   for(int i = 0; i < ArraySize(allowedSymbols); i++) {
      if(_Symbol == allowedSymbols[i]) { 
         symbolAllowed = true; 
         break; 
      }
   }
   
   if(!symbolAllowed) {
      string msg = "EA DIAMOND ne peut pas trader le symbole " + _Symbol;
      Alert(msg);
      if(EnableSoundAlerts) PlaySound("alert.wav");
      return INIT_FAILED;
   }

   // =====================================================
   // SECTION 2 : INITIALISATION DES VARIABLES GLOBALES
   // =====================================================
   g_LastEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   g_LastBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   g_ATRValue = 0.0;
   g_IsGold = (StringFind(_Symbol, "GOLD") >= 0 || StringFind(_Symbol, "XAUUSD") >= 0);
   g_IsCrypto = (StringFind(_Symbol, "BTC") >= 0);
   g_ConsecutiveLosses = 0;
   g_MartingaleStep = 0;
   g_LastLotSize = InitialLot;

   // =====================================================
   // SECTION 3 : INITIALISATION DES PERFORMANCES DES STRATÉGIES
   // =====================================================
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      // Initialisation de la structure de performance
      strategyPerformance[i].strategy = (ENUM_STRATEGY)(i+1);
      strategyPerformance[i].totalTrades = 0;
      strategyPerformance[i].wins = 0;
      strategyPerformance[i].losses = 0;
      strategyPerformance[i].totalProfit = 0.0;
      strategyPerformance[i].winRate = 0.0;
      strategyPerformance[i].profitFactor = 0.0;
      strategyPerformance[i].enabled = true;
      strategyPerformance[i].lastTradeTime = 0;
      strategyPerformance[i].weight = 1.0;
      strategyPerformance[i].recentPerformance = 0.0;
      
      // Attribution des poids selon les paramètres d'entrée
      switch(strategyPerformance[i].strategy) {
         case S_CHECKLIST: 
            strategyPerformance[i].weight = StrategyWeight_Checklist; 
            break;
         case S_BREAKOUT_RANGE: 
            strategyPerformance[i].weight = StrategyWeight_Breakout; 
            break;
         case S_PULLBACK_EMA: 
            strategyPerformance[i].weight = StrategyWeight_Pullback; 
            break;
         case S_SUPERTREND: 
            strategyPerformance[i].weight = StrategyWeight_SuperTrend; 
            break;
         case S_RETEST_SR: 
            strategyPerformance[i].weight = StrategyWeight_SRRetest; 
            break;
         case S_SCALPING: 
            strategyPerformance[i].weight = StrategyWeight_Scalping; 
            break;
         case S_ICHIMOKU: 
            strategyPerformance[i].weight = StrategyWeight_Ichimoku; 
            break;
         case S_PRICE_ACTION: 
            strategyPerformance[i].weight = StrategyWeight_PriceAction; 
            break;
      }
   }

   // =====================================================
   // SECTION 4 : INITIALISATION DES INDICATEURS
   // =====================================================
   if(!strategyManager.InitializeIndicators()) {
      Print("Échec d'initialisation des indicateurs - on continue sans SuperTrend");
      
      // Désactivation automatique de la stratégie SuperTrend si échec
      for(int i = 0; i < STRATEGY_COUNT; i++) {
         if(strategyPerformance[i].strategy == S_SUPERTREND) {
            strategyPerformance[i].enabled = false;
            Print("Stratégie SuperTrend désactivée automatiquement");
            
            if(EnableNotifications) {
               Alert("SuperTrend désactivé - Erreur d'initialisation");
               if(EnableSoundAlerts) PlaySound("alert.wav");
            }
         }
      }
   }

   // =====================================================
   // SECTION 5 : INITIALISATION DU DASHBOARD
   // =====================================================
   UpdateDashboard();
   
   // =====================================================
   // SECTION 6 : CONFIGURATION DU GRAPHIQUE
   // =====================================================
   ChartSetInteger(0, CHART_SHOW_TRADE_LEVELS, false);    // Cacher SL/TP
   ChartSetInteger(0, CHART_SHOW_TRADE_HISTORY, false);   // Cacher les flèches d'entrée/sortie
   ChartSetInteger(0, CHART_MODE, CHART_LINE);            // Affichage en mode ligne

   // =====================================================
   // SECTION 7 : CONFIGURATION DU TIMER
   // =====================================================
   EventSetTimer(1); // Mise à jour toutes les secondes
   lastPerformanceSaveTime = TimeCurrent();

   // =====================================================
   // SECTION 8 : INITIALISATION DU RISK MANAGER
   // =====================================================
   gRiskManager = new CRiskManager(
      MaxDailyLossPercent, 
      MaxLossPercent, 
      MaxConsecutiveLosses, 
      PauseAfterLosses, 
      PauseDurationMinutes
   );

   // =====================================================
   // SECTION 9 : INITIALISATION DU TRADE MANAGER
   // =====================================================
   // Initialisation explicite du suivi des trades
   gTradeManager.InitializeTradeTracking();
   
   // Version alternative avec vérification (si la méthode retourne bool)
   /*
   if(!gTradeManager.InitializeTradeTracking()) {
      Alert("[ERREUR] Échec de l'initialisation du suivi des trades");
      return INIT_FAILED;
   }
   */

   // =====================================================
   // SECTION 10 : MESSAGE FINAL D'INITIALISATION
   // =====================================================
   Print("[INIT] Système de tracking des trades initialisé");
   Print("EA DIAMOND initialisé avec succès sur ", _Symbol, " ", EnumToString(_Period));
   
   return INIT_SUCCEEDED;
}
//---------FIN ONINIT ---------------------------//


void OnTick() {
   
   // === DEBUT - CODE DIAGNOSTIC CORRIGÉ === //
static bool firstRun = true;
if(firstRun && !MQLInfoInteger(MQL_OPTIMIZATION)) {  // Correction ici
   firstRun = false;
   Print("=== DEBUT DIAGNOSTIC ===");
   Print("Heure actuelle: ", TimeCurrent());
   
   // Correction de la ligne problématique :
   if(HistoryDealsTotal() > 0) {
      ulong lastTicket = HistoryDealGetTicket(HistoryDealsTotal()-1);
      Print("Dernier trade historique: ", TimeToString(HistoryDealGetInteger(lastTicket, DEAL_TIME)));
   } else {
      Print("Aucun trade dans l'historique");
   }
   
   HistorySelect(0, TimeCurrent());
   RefreshStrategyStats();
}
// === FIN - CODE DIAGNOSTIC === //
   
   g_SLatrMult = InpSLatrMult;
   g_TPatrMult = InpTPatrMult;
   g_SuperTrendMultiplier = SuperTrend_Multiplier;

   // 🔁 Met à jour les statistiques de performance des stratégies en live
   RefreshStrategyStats();
   
   static int tickCount = 0;
   tickCount++;

   // Logs de débogage périodiques
   if(EnableDebugLog && tickCount % 100 == 0) {
      Print("=== STATUT EA ===");
      Print("Heure: ", TimeCurrent());
      Print("Symbol: ", _Symbol);
      Print("Timeframe: ", EnumToString(_Period));
      Print("EA active: ", ea_is_active);
      Print("Stratégies actives:");
      for(int i = 0; i < STRATEGY_COUNT; i++) {
         if(strategyPerformance[i].enabled)
            Print("- ", EnumToString(strategyPerformance[i].strategy));
      }
   }

   // Vérification du mode backtest ou pause
   if(!ea_is_active || EnableBacktestMode) {
      Comment("EA DIAMOND - " + (EnableBacktestMode ? "BACKTEST MODE" : "PAUSED"));
      return;
   }

   // Vérification des heures de trading
   if(!strategyManager.IsTradingHours()) {
      Comment("EA DIAMOND - HORS HEURES DE TRADING");
      return;
   }

   // Vérification du spread
   double spread_pips = strategyManager.GetSpreadPips();
   double max_spread_pips = strategyManager.GetMaxSpreadForSymbol();
   if(spread_pips > max_spread_pips) {
      Comment("Spread trop élevé : ", DoubleToString(spread_pips,1), 
             " pips (Max autorisé : ", DoubleToString(max_spread_pips,1), ")");
      if(EnableDebugLog) {
         PrintFormat("[SPREAD] Blocage %s - Spread actuel: %.1f pips > Seuil: %.1f pips",
                    _Symbol, spread_pips, max_spread_pips);
      }
      return;
   }

   // Mise à jour périodique du dashboard
   static datetime lastDashboardUpdate = 0;
   if(TimeCurrent() - lastDashboardUpdate >= 1) {
      UpdateDashboard();
      lastDashboardUpdate = TimeCurrent();
   }

   // Vérification des données disponibles
   if(Bars(_Symbol, _Period) < MIN_BARS_REQUIRED) {
      Print("OnTick - Données insuffisantes pour ", _Symbol, 
            " (", Bars(_Symbol, _Period), " barres)");
      return;
   }

   // Vérification périodique des indicateurs
   static datetime lastIndicatorCheck = 0;
   if(TimeCurrent() - lastIndicatorCheck >= 30) {
      if(!strategyManager.AreIndicatorsReady()) {
         Print("Réinitialisation des indicateurs...");
         if(!strategyManager.InitializeIndicators()) {
            Alert("Échec critique de l'initialisation des indicateurs!");
            if(EnableSoundAlerts) PlaySound("alert.wav");
         }
      }
      lastIndicatorCheck = TimeCurrent();
   }

   // Mise à jour de la valeur ATR
   double bufAtr[];
   if(atrHandle != INVALID_HANDLE &&
      CopyBuffer(atrHandle, 0, 0, 1, bufAtr) > 0 &&
      MathIsValidNumber(bufAtr[0])) {
      g_ATRValue = bufAtr[0];
   }
   else if(EnableDebugLog) {
      Print("[ATR] Valeur anormale ou ATR indisponible");
   }

   // Gestion des positions existantes
   CheckIntelligentExit();
   tradeManager.ManagePositions();

   // Vérification de la possibilité d'ouvrir une nouvelle position
   if(!tradeManager.CanOpenNewPosition(_Symbol)) {
      Print("DEBUG OnTick: CanOpenNewPosition=false, pas de nouveau trade possible");
      return;
   }

   // Vérification des conditions de trading et génération des signaux
   STradeSignal signal;
   signal.valid = false;
   bool ok = CheckTradingConditions(signal);
   
   if(ok && signal.valid) {
      double lots = gRiskManager.CalculatePositionSize(signal.price, signal.sl);
      
      if(lots > 0.0 && gRiskManager.IsTradeAllowed()) {
         bool tradeOk = tradeManager.ExecuteTrade(signal);
         if(!tradeOk) {
            PrintFormat("❌ Échec de l'exécution du trade (code %d)", GetLastError());
         } else {
            lastTradeTime = TimeCurrent();
         }
      }
   }
}

void OnDeinit(const int reason) {
   // Nettoyage à la désinitialisation
   strategyManager.ReleaseAllHandles();
   DeleteDashboard();
   EventKillTimer();
}

void OnTimer() {
   UpdateDashboard();
   
   // Sauvegarde périodique des performances
   if(TimeCurrent() - lastPerformanceSaveTime > PERFORMANCE_SAVE_INTERVAL) {
      SavePerformanceToFile();
   }
}

//===================================================
// SECTION 9 : FONCTIONS SUPPLEMENTAIRES
//===================================================
/**
 * Fonction CheckTradingConditions - Vérifie les conditions de trading
 * @param signal Référence à la structure STradeSignal qui sera remplie si les conditions sont remplies
 * @return bool - Retourne true si les conditions de trading sont remplies, false sinon
 *
 * Cette fonction :
 * 1. Analyse l'état du marché (calme, modéré, volatile)
 * 2. Ajuste les paramètres selon la volatilité
 * 3. Génère les signaux de chaque stratégie
 * 4. Vérifie la cohérence avec la tendance globale
 * 5. Prend la décision finale de trading
 */
bool CheckTradingConditions(STradeSignal &signal) {
   // 1. Analyse et adaptation aux conditions du marché
   ENUM_MARKET_CONDITION marketCond = AnalyzeMarketCondition();
   AdjustParametersByMarketCondition(marketCond);
   
   // 2. Vérification des conditions de base
   if(!gRiskManager.IsTradeAllowed()) {
      Print("DEBUG: RiskManager refuse le trade");
      signal.valid = false;
      return false;
   }

   if(!strategyManager.AreIndicatorsReady()) {
      Print("DEBUG: Les indicateurs ne sont pas prêts");
      signal.valid = false;
      return false;
   }

   // 3. Vérification du temps minimum entre les trades
   if(!gRiskManager.CheckMinTimeBetweenTrades(MinMinutesBetweenTrades)) {
      Print("DEBUG: Temps minimum entre les trades non respecté");
      signal.valid = false;
      return false;
   }

   // 4. Génération des signaux pour chaque stratégie
   STradeSignal signals[STRATEGY_COUNT];
   int voteBuy = 0, voteSell = 0;
   int totalEnabledStrategies = 0;
   double totalBuyStrength = 0.0, totalSellStrength = 0.0;

   for(int i = 0; i < STRATEGY_COUNT; i++) {
      if(!strategyPerformance[i].enabled) continue;
      
      totalEnabledStrategies++;
      signals[i].valid = false;

      switch(strategyPerformance[i].strategy) {
         case S_CHECKLIST:
            strategyManager.ChecklistStrategySignal(signals[i]);
            break;
         case S_SUPERTREND:
            strategyManager.DetectSuperTrendSignal(signals[i]);
            break;
         case S_RETEST_SR:
            strategyManager.DetectSRRetestSignal(signals[i]);
            break;
         case S_BREAKOUT_RANGE:
            strategyManager.DetectBreakoutSignal(signals[i]);
            break;
         case S_PULLBACK_EMA:
            strategyManager.DetectPullbackEMASignal(signals[i]);
            break;
         case S_SCALPING:
            strategyManager.DetectScalpingSignal(signals[i]);
            break;
         case S_ICHIMOKU:
            strategyManager.DetectIchimokuSignal(signals[i]);
            break;
         case S_PRICE_ACTION:
            strategyManager.DetectPriceActionSignal(signals[i]);
            break;
      }

      if(signals[i].valid) {
         if(signals[i].isBuySignal) {
            voteBuy++;
            totalBuyStrength += signals[i].strength * strategyPerformance[i].weight;
         } else {
            voteSell++;
            totalSellStrength += signals[i].strength * strategyPerformance[i].weight;
         }
      }
   }

   // 5. Décision finale basée sur les votes et la force des signaux
   int totalVotes = voteBuy + voteSell;
   if(totalVotes >= MinStrategyConfirmations) {
      // 5.1 Vérification de la tendance et de la moyenne pondérée
      bool isBullishTrend = IsTrendBullish(_Period);
      
      // 5.2 Signal d'achat avec vérification de tendance
      if(totalBuyStrength > totalSellStrength && totalBuyStrength >= 70.0) {
         if(!CheckTrendConsistency(true)) {
            signal.valid = false;
            return false;
         }
         
         signal.valid = true;
         signal.isBuySignal = true;
         signal.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         signal.confirmations = totalVotes;
         signal.strategy = S_CHECKLIST; // Stratégie principale
         signal.comment = StringFormat("Achat confirmé (%d strat, Force: %.1f%%, Marché: %s)", 
                                     totalVotes, totalBuyStrength, EnumToString(marketCond));
         
         // Calcul des SL/TP moyens pondérés
         double avgSL = 0, avgTP = 0;
         double totalWeight = 0.0;
         
         for(int i = 0; i < STRATEGY_COUNT; i++) {
            if(signals[i].valid && signals[i].isBuySignal) {
               double weight = signals[i].strength * strategyPerformance[i].weight;
               avgSL += signals[i].sl * weight;
               avgTP += signals[i].tp * weight;
               totalWeight += weight;
            }
         }
         
         if(totalWeight > 0) {
            signal.sl = avgSL / totalWeight;
            signal.tp = avgTP / totalWeight;
         } else {
            strategyManager.SetStopLossTakeProfit(signal, true);
         }
         
         PrintFormat("Signal ACHAT: %d confirmations (Force: %.1f%%) - Tendance: %s", 
                    signal.confirmations, totalBuyStrength, isBullishTrend ? "Haussière" : "Baissière");
         return true;
      }
      // 5.3 Signal de vente avec vérification de tendance
      else if(totalSellStrength > totalBuyStrength && totalSellStrength >= 70.0) {
         if(!CheckTrendConsistency(false)) {
            signal.valid = false;
            return false;
         }
         
         signal.valid = true;
         signal.isBuySignal = false;
         signal.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         signal.confirmations = totalVotes;
         signal.strategy = S_CHECKLIST; // Stratégie principale
         signal.comment = StringFormat("Vente confirmée (%d strat, Force: %.1f%%, Marché: %s)", 
                                     totalVotes, totalSellStrength, EnumToString(marketCond));
         
         // Calcul des SL/TP moyens pondérés
         double avgSL = 0, avgTP = 0;
         double totalWeight = 0.0;
         
         for(int i = 0; i < STRATEGY_COUNT; i++) {
            if(signals[i].valid && !signals[i].isBuySignal) {
               double weight = signals[i].strength * strategyPerformance[i].weight;
               avgSL += signals[i].sl * weight;
               avgTP += signals[i].tp * weight;
               totalWeight += weight;
            }
         }
         
         if(totalWeight > 0) {
            signal.sl = avgSL / totalWeight;
            signal.tp = avgTP / totalWeight;
         } else {
            strategyManager.SetStopLossTakeProfit(signal, false);
         }
         
         PrintFormat("Signal VENTE: %d confirmations (Force: %.1f%%) - Tendance: %s", 
                    signal.confirmations, totalSellStrength, isBullishTrend ? "Haussière" : "Baissière");
         return true;
      }
      else {
         Print("Conditions non remplies : Moyenne pondérée <70% ou contre-tendance");
         PrintFormat("Buy Strength: %.1f, Sell Strength: %.1f, Trend: %s",
                    totalBuyStrength, totalSellStrength, isBullishTrend ? "Bullish" : "Bearish");
      }
   }

   // 6. Aucun signal valide trouvé
   signal.valid = false;
   return false;
}

//------------------------------------//

bool PartialClose(ulong ticket, double percent) {
   if(!PositionSelectByTicket(ticket)) return false;
   
   double volume = PositionGetDouble(POSITION_VOLUME);
   double step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   int lotDigits = (step > 0) ? (int)MathRound(-MathLog10(step)) : 2;
   double volClose = NormalizeDouble(volume * (percent / 100.0), lotDigits);

   if(volClose < SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN)) return false;

   CTrade t; 
   t.SetExpertMagicNumber(MagicNumber);
   return t.PositionClosePartial(ticket, volClose);
}

void CheckIntelligentExit() {
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;

      if(!PositionSelectByTicket(ticket)) continue;

      if(PositionGetString(POSITION_SYMBOL) != _Symbol || 
         (int)PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;

      double entry = PositionGetDouble(POSITION_PRICE_OPEN);
      double atr = strategyManager.GetCurrentATR();
      if(atr <= 0) continue;

      double currentPrice = (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) ?
                          SymbolInfoDouble(_Symbol, SYMBOL_BID) :
                          SymbolInfoDouble(_Symbol, SYMBOL_ASK);

      // Fermeture partielle si le profit atteint un multiple de l'ATR
      if(MathAbs(currentPrice - entry) > atr * PartialCloseATRMultiplier) {
         PartialClose(ticket, PartialClosePercent);
      }
   }
}

void SavePerformanceToFile() {
   int h = FileOpen("DIAMOND_stats.csv", FILE_READ|FILE_WRITE|FILE_CSV);
   if(h == INVALID_HANDLE) return;
   
   FileSeek(h, 0, SEEK_END);
   string line = TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS) + "," +
                 DoubleToString(AccountInfoDouble(ACCOUNT_BALANCE), 2) + "," +
                 DoubleToString(AccountInfoDouble(ACCOUNT_EQUITY), 2) + "\n";
   FileWriteString(h, line);
   FileClose(h);
   lastPerformanceSaveTime = TimeCurrent();
}

void CloseAllPositions() {
   CTrade t; 
   t.SetExpertMagicNumber(MagicNumber);
   
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;

      if(!PositionSelectByTicket(ticket)) continue;

      if(PositionGetString(POSITION_SYMBOL) != _Symbol || 
         (int)PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;

      t.PositionClose(ticket);
   }
   
   // Réinitialisation du suivi des pertes consécutives
   g_ConsecutiveLosses = 0;
   g_MartingaleStep = 0;
   
   if(EnableNotifications) {
      gNotifier.SendNotification("🔴 Toutes les positions ont été fermées");
   }
}

//+------------------------------------------------------------------+
//| FIN DU CODE - DIAMOND EA VER39 - OPTIMISÉE ET COMPLÈTE        |
//+------------------------------------------------------------------+